WEBVTT

1
00:00:00.160 --> 00:00:01.360
All right, so in this particular

2
00:00:01.360 --> 00:00:03.520
video, let's see how we can

3
00:00:03.520 --> 00:00:05.640
solve this session problem using

4
00:00:05.640 --> 00:00:08.240
something known as JSON web tokens.

5
00:00:08.240 --> 00:00:10.120
So that number one, I don't have to

6
00:00:10.120 --> 00:00:12.480
make an API call or a query call

7
00:00:12.480 --> 00:00:14.240
to the database and I don't

8
00:00:14.240 --> 00:00:16.318
overwhelm the database with every

9
00:00:16.318 --> 00:00:19.520
request and how I can increase my

10
00:00:19.520 --> 00:00:20.160
speed.

11
00:00:20.160 --> 00:00:21.360
So let's search for something

12
00:00:21.360 --> 00:00:22.880
known as JSON web token.

13
00:00:22.880 --> 00:00:23.720
Okay, so what is this?

14
00:00:23.720 --> 00:00:24.760
JSON web tokens.

15
00:00:24.760 --> 00:00:26.240
So this is the jwt, also

16
00:00:26.240 --> 00:00:28.080
known as JSON web tokens.

17
00:00:28.080 --> 00:00:30.400
The idea behind JSON web tokens is

18
00:00:30.400 --> 00:00:33.280
what if I could create a random

19
00:00:33.280 --> 00:00:35.160
string, let's say something like,

20
00:00:35.160 --> 00:00:38.040
you know, a random string and actual

21
00:00:38.040 --> 00:00:41.200
information about the user, such as

22
00:00:41.200 --> 00:00:44.080
name, such as all the details about

23
00:00:44.080 --> 00:00:47.760
the user can be encrypted inside the

24
00:00:47.760 --> 00:00:48.400
token.

25
00:00:48.400 --> 00:00:51.200
I mean the token itself contains

26
00:00:51.200 --> 00:00:51.760
the information.

27
00:00:52.480 --> 00:00:55.350
So that is the idea behind the jwt.

28
00:00:55.350 --> 00:00:56.470
So you can see that if this is

29
00:00:56.470 --> 00:00:58.750
a token, this token actually

30
00:00:58.750 --> 00:01:00.030
contains this information.

31
00:01:00.670 --> 00:01:02.030
Sub name id.

32
00:01:02.030 --> 00:01:03.630
For example, I can even add,

33
00:01:03.630 --> 00:01:04.989
let's say email, right?

34
00:01:04.989 --> 00:01:06.910
I can add email as P.

35
00:01:06.910 --> 00:01:08.510
So you can see that this particular

36
00:01:08.510 --> 00:01:11.070
token contains this particular data.

37
00:01:11.070 --> 00:01:12.870
So that means instead of returning

38
00:01:12.870 --> 00:01:14.630
a session id, I can return a,

39
00:01:14.630 --> 00:01:17.310
token, an encoded token

40
00:01:17.310 --> 00:01:19.510
which contains the all

41
00:01:19.510 --> 00:01:21.510
the information inside the token.

42
00:01:21.510 --> 00:01:22.390
So that is the basic

43
00:01:22.390 --> 00:01:23.630
idea behind the token.

44
00:01:23.630 --> 00:01:25.550
So I don't have to make an API call

45
00:01:25.550 --> 00:01:27.850
to the database to get the data.

46
00:01:27.850 --> 00:01:29.490
Okay, now these tokens are

47
00:01:29.490 --> 00:01:30.850
actually signed tokens.

48
00:01:30.850 --> 00:01:32.850
That means our server can

49
00:01:32.850 --> 00:01:35.050
basically create a token.

50
00:01:35.050 --> 00:01:36.690
Everyone can read what is

51
00:01:36.690 --> 00:01:38.090
the data inside the token,

52
00:01:38.090 --> 00:01:39.330
but no one can change it.

53
00:01:39.330 --> 00:01:40.450
Because to change the token

54
00:01:40.450 --> 00:01:41.370
you need a secret.

55
00:01:42.010 --> 00:01:43.970
Because if anyone can change this

56
00:01:43.970 --> 00:01:45.770
token, that's a very risky thing.

57
00:01:45.770 --> 00:01:47.330
You generate a token for me,

58
00:01:47.330 --> 00:01:49.290
I can update my user ID to point

59
00:01:49.290 --> 00:01:50.770
to your user ID and I can

60
00:01:50.770 --> 00:01:52.440
do something on your behalf.

61
00:01:52.440 --> 00:01:54.680
So these tokens are absolutely safe.

62
00:01:54.680 --> 00:01:56.240
Anyone can read these tokens,

63
00:01:56.240 --> 00:01:58.160
but no one can tamper or change

64
00:01:58.160 --> 00:02:01.000
these tokens until and unless

65
00:02:01.000 --> 00:02:03.320
you have the secret key.

66
00:02:03.320 --> 00:02:05.000
So as a developer you should always

67
00:02:05.000 --> 00:02:07.240
keep the secret key very secure.

68
00:02:07.240 --> 00:02:08.318
So what we are going to do is

69
00:02:08.318 --> 00:02:09.320
we are going to create

70
00:02:09.320 --> 00:02:12.040
a JWTSecret, which is something

71
00:02:12.040 --> 00:02:13.720
like, you know, Superman.

72
00:02:14.440 --> 00:02:16.080
So ideally it should be very long

73
00:02:16.080 --> 00:02:17.880
and something not guessable.

74
00:02:17.880 --> 00:02:19.000
Now what we have to do is we have

75
00:02:19.000 --> 00:02:22.200
to say pnpm install JSON web token.

76
00:02:22.200 --> 00:02:23.200
Okay, so this is the whole

77
00:02:23.200 --> 00:02:24.400
name JSON web token.

78
00:02:24.400 --> 00:02:25.240
Nice.

79
00:02:25.240 --> 00:02:27.640
Now see what we can do is let's try

80
00:02:27.640 --> 00:02:28.960
to refactor this

81
00:02:28.960 --> 00:02:30.520
particular code to use tokens.

82
00:02:30.520 --> 00:02:31.320
Okay?

83
00:02:31.320 --> 00:02:34.040
Number one thing, how do you login

84
00:02:34.040 --> 00:02:35.640
now that's the thing that when

85
00:02:35.640 --> 00:02:38.120
you log in, technically you don't

86
00:02:38.120 --> 00:02:39.720
want to create a session, right?

87
00:02:39.720 --> 00:02:41.360
We are not going to create

88
00:02:41.360 --> 00:02:43.200
a session, so a session

89
00:02:43.200 --> 00:02:44.680
creation is not required.

90
00:02:44.680 --> 00:02:46.370
Rather, what we should do is

91
00:02:46.370 --> 00:02:48.690
we should basically create

92
00:02:48.690 --> 00:02:50.450
a token for the user.

93
00:02:50.450 --> 00:02:52.050
How to create a token?

94
00:02:52.050 --> 00:02:53.810
First let's create a payload

95
00:02:53.810 --> 00:02:55.290
that what all information I

96
00:02:55.290 --> 00:02:56.930
want to store in the token.

97
00:02:56.930 --> 00:02:58.530
So I am going to store an ID

98
00:02:58.530 --> 00:03:01.410
that is existing user.id

99
00:03:01.410 --> 00:03:02.930
and I want to store email.

100
00:03:02.930 --> 00:03:06.090
Let's say existing user.email and I

101
00:03:06.090 --> 00:03:07.610
want to store the name of the user

102
00:03:07.610 --> 00:03:09.490
that is existing user email.

103
00:03:10.210 --> 00:03:12.720
Now to create a token token,

104
00:03:12.720 --> 00:03:14.880
I can just say import.

105
00:03:16.720 --> 00:03:19.800
Okay, import JWT

106
00:03:19.800 --> 00:03:21.280
from JSON web tokens.

107
00:03:21.280 --> 00:03:23.040
So this is what we have imported.

108
00:03:23.040 --> 00:03:26.080
And then you can just say jwt.sign.

109
00:03:26.080 --> 00:03:28.239
okay, you are signing a token

110
00:03:28.239 --> 00:03:30.440
for this particular payload and then

111
00:03:30.440 --> 00:03:32.200
you have to give the secret key that

112
00:03:32.200 --> 00:03:38.160
is process.en sorry process.env.

113
00:03:38.160 --> 00:03:38.960
what is the secret?

114
00:03:40.080 --> 00:03:42.720
Inside this is the secret JWT secret.

115
00:03:43.280 --> 00:03:45.520
This creates a token for you.

116
00:03:46.800 --> 00:03:49.200
Jwt.sign this thing.

117
00:03:49.200 --> 00:03:51.080
And this token can now be

118
00:03:51.080 --> 00:03:52.640
returned to the user back.

119
00:03:53.200 --> 00:03:54.280
So now let me show you what

120
00:03:54.280 --> 00:03:55.359
this token looks like.

121
00:03:55.359 --> 00:03:56.800
Okay, so what we are keeping

122
00:03:56.800 --> 00:03:59.040
in the token is id, email and name.

123
00:03:59.600 --> 00:04:01.200
Let's go back to the postman.

124
00:04:01.200 --> 00:04:03.200
So let me just spin up my postman.

125
00:04:03.200 --> 00:04:06.550
Okay, so here is the postman.

126
00:04:06.550 --> 00:04:08.830
And let's try to do a login.

127
00:04:08.830 --> 00:04:09.750
And send.

128
00:04:09.750 --> 00:04:11.750
Okay, I forgot to run the server,

129
00:04:12.870 --> 00:04:16.310
so PNPM dev and enter.

130
00:04:16.310 --> 00:04:17.990
Now let's see what is happening.

131
00:04:17.990 --> 00:04:19.269
And send.

132
00:04:19.269 --> 00:04:21.750
So all right, so we got an error.

133
00:04:21.750 --> 00:04:23.510
Let's see what is the error here.

134
00:04:23.510 --> 00:04:24.230
The.

135
00:04:24.230 --> 00:04:25.430
Okay, so my bad, actually

136
00:04:25.430 --> 00:04:27.070
the docker compose is not running.

137
00:04:27.070 --> 00:04:29.190
So docker compose up hyphen D.

138
00:04:31.520 --> 00:04:32.080
It says.

139
00:04:32.080 --> 00:04:33.440
Okay, so actually, you know,

140
00:04:33.440 --> 00:04:34.560
I just restarted my machine

141
00:04:34.560 --> 00:04:35.800
and the docker is not running.

142
00:04:35.800 --> 00:04:37.040
So that was the problem.

143
00:04:37.040 --> 00:04:38.000
So let me just,

144
00:04:38.000 --> 00:04:39.040
let's wait for a while.

145
00:04:39.040 --> 00:04:40.880
Yeah, now I think everything is

146
00:04:40.880 --> 00:04:41.560
up and running.

147
00:04:41.560 --> 00:04:43.440
Now let's just do a PNPM dev.

148
00:04:43.440 --> 00:04:44.160
Cool.

149
00:04:44.160 --> 00:04:45.280
And send.

150
00:04:45.280 --> 00:04:46.280
So can you see that?

151
00:04:46.280 --> 00:04:48.640
This random string, this is a token.

152
00:04:48.640 --> 00:04:50.520
Now if you have noticed, we are not

153
00:04:50.520 --> 00:04:52.360
storing this token in the database.

154
00:04:52.360 --> 00:04:54.200
There is absolutely no need to store

155
00:04:54.200 --> 00:04:55.880
these tokens in the database because

156
00:04:55.880 --> 00:04:57.420
if I paste my token here, See,

157
00:04:57.420 --> 00:04:58.380
See, this is what we are getting.

158
00:04:59.260 --> 00:05:00.500
By the way, name is wrong.

159
00:05:00.500 --> 00:05:01.420
My bad.

160
00:05:01.420 --> 00:05:02.780
Because this must be named.

161
00:05:02.780 --> 00:05:03.860
Yeah, so you can see

162
00:05:03.860 --> 00:05:04.940
that this is the token.

163
00:05:04.940 --> 00:05:06.780
Now you might be thinking that, hey,

164
00:05:06.780 --> 00:05:08.700
someone can come and change this

165
00:05:08.700 --> 00:05:10.860
token, but actually no, because if

166
00:05:10.860 --> 00:05:13.580
you change the token the signature

167
00:05:13.580 --> 00:05:15.500
of the token also changes.

168
00:05:15.500 --> 00:05:18.140
And to change that particular

169
00:05:18.140 --> 00:05:19.580
token, you actually

170
00:05:19.580 --> 00:05:21.580
need this particular key.

171
00:05:21.580 --> 00:05:22.940
So of course the user will

172
00:05:22.940 --> 00:05:24.380
never have this particular key.

173
00:05:24.380 --> 00:05:25.660
So they cannot really

174
00:05:25.660 --> 00:05:26.620
change the token.

175
00:05:27.180 --> 00:05:28.500
Now what we have to do is,

176
00:05:28.500 --> 00:05:30.780
okay, the login part is done.

177
00:05:30.780 --> 00:05:33.020
Now, in order to see if the current

178
00:05:33.020 --> 00:05:34.460
user is logged in or not.

179
00:05:34.460 --> 00:05:35.980
Now there is a thing.

180
00:05:35.980 --> 00:05:37.620
We don't really need this

181
00:05:37.620 --> 00:05:38.620
whole thing, right?

182
00:05:38.620 --> 00:05:40.500
What we need is we need to read

183
00:05:40.500 --> 00:05:41.980
the token from the headers.

184
00:05:41.980 --> 00:05:44.540
And as a part of standardization,

185
00:05:44.540 --> 00:05:45.500
there is always

186
00:05:45.500 --> 00:05:48.620
an authorization header, okay?

187
00:05:48.620 --> 00:05:51.220
So as a best practice, there must be

188
00:05:51.220 --> 00:05:54.230
a header that named as authorization

189
00:05:54.230 --> 00:05:57.590
whose value must be bearer.

190
00:05:57.590 --> 00:05:59.670
And the token goes here.

191
00:05:59.670 --> 00:06:01.590
So this is the standard practice

192
00:06:01.590 --> 00:06:03.030
that everyone follows.

193
00:06:03.030 --> 00:06:04.790
So this is basically your token

194
00:06:04.790 --> 00:06:07.670
header whose value should be bearer

195
00:06:07.670 --> 00:06:10.710
space and the actual token, okay?

196
00:06:10.710 --> 00:06:12.270
So that means first of all,

197
00:06:12.270 --> 00:06:14.350
if there is no token, if there

198
00:06:14.350 --> 00:06:15.350
is no token header, that

199
00:06:15.350 --> 00:06:17.030
means user is not logged in.

200
00:06:17.030 --> 00:06:17.910
Okay?

201
00:06:17.910 --> 00:06:19.750
Then you have to check that if

202
00:06:20.430 --> 00:06:23.030
okay, not token header

203
00:06:23.030 --> 00:06:24.950
dot starts with okay, it

204
00:06:24.950 --> 00:06:26.750
should start with the bearer.

205
00:06:26.750 --> 00:06:28.590
Okay, because that's the standard.

206
00:06:28.590 --> 00:06:30.110
Then you can just say return

207
00:06:30.110 --> 00:06:34.990
response.status as a400.JSON

208
00:06:34.990 --> 00:06:38.270
saying error and you can just say

209
00:06:38.270 --> 00:06:40.590
authorization header

210
00:06:41.230 --> 00:06:44.030
must start with bearer.

211
00:06:44.750 --> 00:06:45.230
Right?

212
00:06:45.230 --> 00:06:45.630
Nice.

213
00:06:45.630 --> 00:06:46.150
Bearer.

214
00:06:46.150 --> 00:06:48.430
Okay, if it starts with bearer,

215
00:06:48.430 --> 00:06:49.750
what you can basically do is you

216
00:06:49.750 --> 00:06:51.790
can basically extract the token.

217
00:06:51.790 --> 00:06:53.950
What I could do is if I somehow

218
00:06:54.510 --> 00:06:56.190
split this particular thing

219
00:06:56.190 --> 00:06:57.670
using the bearer word, right?

220
00:06:57.670 --> 00:06:58.830
Or if I split it using

221
00:06:58.830 --> 00:06:59.790
the space, okay?

222
00:06:59.790 --> 00:07:02.750
So I can just say token header.

223
00:07:02.750 --> 00:07:05.630
Split it using the space and take

224
00:07:05.630 --> 00:07:07.470
the first index that is this token.

225
00:07:07.470 --> 00:07:08.990
So you got the token.

226
00:07:08.990 --> 00:07:10.590
Now what you should basically

227
00:07:10.590 --> 00:07:11.750
do is you should validate,

228
00:07:11.750 --> 00:07:13.190
you should decode the token.

229
00:07:13.190 --> 00:07:14.750
So I can just say decoded.

230
00:07:15.470 --> 00:07:17.990
Okay, how to decode the token is

231
00:07:17.990 --> 00:07:23.370
basically import jwt from JSON web

232
00:07:23.370 --> 00:07:26.490
token and now you can just say jwt.

233
00:07:26.490 --> 00:07:29.730
Verify you have to pass the token.

234
00:07:29.730 --> 00:07:32.410
And also the same secret that you

235
00:07:32.410 --> 00:07:36.130
have used, that is process env.

236
00:07:36.130 --> 00:07:38.450
What was our key JWT secret.

237
00:07:39.170 --> 00:07:41.730
Now see, if user has changed

238
00:07:41.730 --> 00:07:43.170
something in the token, this

239
00:07:43.170 --> 00:07:44.530
particular step is going to fail.

240
00:07:45.210 --> 00:07:47.210
But if user has not changed something

241
00:07:47.210 --> 00:07:48.690
in the token, the decoder will

242
00:07:48.690 --> 00:07:50.450
be the actual user object, whatever

243
00:07:50.450 --> 00:07:51.690
you have stored in the token.

244
00:07:51.690 --> 00:07:53.370
Now technically I can just

245
00:07:53.370 --> 00:07:55.450
remove all this thing, right?

246
00:07:55.450 --> 00:07:57.770
Everything can be removed and this

247
00:07:57.770 --> 00:07:59.530
can be equals to the decoder.

248
00:07:59.530 --> 00:08:00.569
That's it.

249
00:08:00.569 --> 00:08:03.210
Absolutely no database call.

250
00:08:03.210 --> 00:08:04.890
You get the token header, which

251
00:08:04.890 --> 00:08:06.250
basically looks something like this.

252
00:08:06.890 --> 00:08:08.090
No token that means

253
00:08:08.090 --> 00:08:09.370
user is not logged in.

254
00:08:09.370 --> 00:08:11.010
If it doesn't start with bearer,

255
00:08:11.010 --> 00:08:13.250
you return a bad request error,

256
00:08:13.250 --> 00:08:15.050
you get the token from the header,

257
00:08:15.050 --> 00:08:17.450
you Decode it, you verify it, set

258
00:08:17.450 --> 00:08:19.810
the request header, and that is it.

259
00:08:19.810 --> 00:08:21.290
So that means now if I try

260
00:08:21.290 --> 00:08:22.810
to get myself, you can see it

261
00:08:22.810 --> 00:08:24.130
says you are not logged in.

262
00:08:24.130 --> 00:08:24.770
Why?

263
00:08:24.770 --> 00:08:25.890
Because this particular

264
00:08:26.450 --> 00:08:29.130
token has to be sent in such

265
00:08:29.130 --> 00:08:30.370
a way that is not this.

266
00:08:30.370 --> 00:08:32.370
Like this authorization

267
00:08:33.730 --> 00:08:38.130
must be bearer token and send.

268
00:08:38.130 --> 00:08:40.090
See, I am logged in.

269
00:08:40.090 --> 00:08:41.289
Also, can you see this

270
00:08:41.289 --> 00:08:42.890
authorization tab here?

271
00:08:42.890 --> 00:08:45.610
You can just say bearer token

272
00:08:45.610 --> 00:08:47.330
and you can actually paste

273
00:08:47.330 --> 00:08:49.610
your token here and send.

274
00:08:49.610 --> 00:08:51.170
So this is actually more nice way

275
00:08:51.170 --> 00:08:52.810
because Postman gives you the out

276
00:08:52.810 --> 00:08:54.170
of the box support for it.

277
00:08:54.170 --> 00:08:55.730
So there is absolutely no need

278
00:08:55.730 --> 00:08:57.410
to set this particular header,

279
00:08:57.410 --> 00:08:59.050
okay, because you already have

280
00:08:59.050 --> 00:09:01.370
it bearer token as a token.

281
00:09:01.370 --> 00:09:03.610
So this automatically sends a header.

282
00:09:03.610 --> 00:09:04.890
Okay, so if you see the hidden,

283
00:09:04.890 --> 00:09:06.090
you can see automatically

284
00:09:06.090 --> 00:09:07.530
an authorization

285
00:09:07.530 --> 00:09:09.600
bearer token is being sent.

286
00:09:09.600 --> 00:09:09.920
Nice.

287
00:09:09.920 --> 00:09:12.040
Okay, so this is how you basically

288
00:09:12.040 --> 00:09:13.680
do a token based authentication.

289
00:09:13.680 --> 00:09:15.120
Now see, when you are generating

290
00:09:15.120 --> 00:09:17.120
tokens, you can even give more

291
00:09:17.120 --> 00:09:18.680
parameters like expires in.

292
00:09:18.680 --> 00:09:19.920
So you can just say expires in.

293
00:09:19.920 --> 00:09:20.960
Let's say one minute.

294
00:09:20.960 --> 00:09:22.600
Now this particular token is

295
00:09:22.600 --> 00:09:24.600
only valid for one minute.

296
00:09:24.600 --> 00:09:26.280
That means after one minute, this

297
00:09:26.280 --> 00:09:28.400
token will no longer be valid.

298
00:09:28.400 --> 00:09:29.680
Okay, what happens if

299
00:09:29.680 --> 00:09:31.200
I change this token?

300
00:09:31.200 --> 00:09:32.360
Let's say if this

301
00:09:32.360 --> 00:09:33.520
was my token, right?

302
00:09:33.520 --> 00:09:34.800
Let me just copy the token,

303
00:09:35.790 --> 00:09:36.910
paste in the debugger.

304
00:09:36.910 --> 00:09:37.990
Because see, publicly

305
00:09:37.990 --> 00:09:39.310
anyone can read it.

306
00:09:39.310 --> 00:09:40.510
I change it.

307
00:09:40.510 --> 00:09:42.350
See, I'm changing something.

308
00:09:42.350 --> 00:09:44.550
Now if I copy this token, which I

309
00:09:44.550 --> 00:09:46.150
changed on the front end, of course,

310
00:09:46.150 --> 00:09:48.110
without the key, and I paste it.

311
00:09:48.110 --> 00:09:48.910
See?

312
00:09:48.910 --> 00:09:49.950
Server crashed.

313
00:09:49.950 --> 00:09:50.310
What?

314
00:09:50.310 --> 00:09:51.189
What is the error?

315
00:09:51.189 --> 00:09:52.590
If you read the error, it

316
00:09:52.590 --> 00:09:53.990
basically says that it is not

317
00:09:53.990 --> 00:09:55.750
able to verify the token.

318
00:09:55.750 --> 00:09:59.150
See, JSON web token error

319
00:09:59.150 --> 00:10:01.010
invalid signature.

320
00:10:01.010 --> 00:10:02.810
So that means if someone tries

321
00:10:02.810 --> 00:10:04.050
to tamper around with

322
00:10:04.050 --> 00:10:05.330
the token, tries to change

323
00:10:05.330 --> 00:10:07.410
the token, the validation fails.

324
00:10:07.410 --> 00:10:08.930
So ideally what you could basically

325
00:10:08.930 --> 00:10:11.090
do is in your middleware, okay?

326
00:10:11.090 --> 00:10:12.130
In your middleware,

327
00:10:12.130 --> 00:10:14.130
you can wrap this particular whole

328
00:10:14.130 --> 00:10:15.570
thing with a try catch.

329
00:10:16.130 --> 00:10:18.610
And if you are somehow in the catch,

330
00:10:18.610 --> 00:10:19.650
okay, you can basically

331
00:10:19.650 --> 00:10:20.850
just call the next function.

332
00:10:20.850 --> 00:10:22.450
That means you are not logged in.

333
00:10:22.450 --> 00:10:23.850
So now if this is a tamper

334
00:10:23.850 --> 00:10:25.010
token, you are not logged in.

335
00:10:25.010 --> 00:10:26.370
So that means you have to use

336
00:10:26.370 --> 00:10:28.520
the Tampa token, which is generated

337
00:10:28.520 --> 00:10:30.320
by the server using that secret

338
00:10:30.320 --> 00:10:32.480
key and then paste in here.

339
00:10:32.480 --> 00:10:33.920
See, you change something

340
00:10:33.920 --> 00:10:35.920
in the token and your

341
00:10:35.920 --> 00:10:37.160
signature is invalid.

342
00:10:37.160 --> 00:10:39.040
See, I changed it.

343
00:10:39.040 --> 00:10:40.160
Copy it.

344
00:10:40.160 --> 00:10:41.960
Okay, now if I use this particular

345
00:10:41.960 --> 00:10:43.760
token, you are not logged in.

346
00:10:43.760 --> 00:10:44.160
Nice.

347
00:10:44.160 --> 00:10:44.480
Right?

348
00:10:44.480 --> 00:10:46.480
I'm not making an API call.

349
00:10:46.480 --> 00:10:48.360
I'm not making a database call.

350
00:10:48.360 --> 00:10:48.960
Why?

351
00:10:48.960 --> 00:10:50.480
Because the actual data

352
00:10:50.480 --> 00:10:52.570
sits inside the token.

353
00:10:52.570 --> 00:10:53.450
That is the beauty

354
00:10:53.450 --> 00:10:55.170
of JSON web tokens.

355
00:10:55.170 --> 00:10:57.210
Okay, so this is how we are doing it.

356
00:10:57.210 --> 00:10:58.370
And by the way, the name is

357
00:10:58.370 --> 00:10:59.410
not coming here because we are

358
00:10:59.410 --> 00:11:00.570
not querying the name here.

359
00:11:00.570 --> 00:11:01.570
So ideally I should

360
00:11:01.570 --> 00:11:02.570
also query the name.

361
00:11:02.570 --> 00:11:04.290
Okay, so that's okay, you can just

362
00:11:04.290 --> 00:11:05.690
update this particular stuff.

363
00:11:05.690 --> 00:11:06.690
But so tokens.

364
00:11:06.690 --> 00:11:08.329
The basic idea behind tokens is

365
00:11:08.329 --> 00:11:09.690
that the actual information

366
00:11:09.690 --> 00:11:11.250
is actually stored inside

367
00:11:11.250 --> 00:11:13.890
the token itself so that you don't

368
00:11:13.890 --> 00:11:15.610
make a database call always.

369
00:11:15.610 --> 00:11:17.170
And because the actual data lives

370
00:11:17.170 --> 00:11:19.290
inside the token, the latency is

371
00:11:19.290 --> 00:11:20.450
very less because you just have

372
00:11:20.450 --> 00:11:22.380
to verify the token, you are not

373
00:11:22.380 --> 00:11:24.460
making an extra database call.

374
00:11:24.460 --> 00:11:26.940
So database is not overwhelmed

375
00:11:26.940 --> 00:11:27.900
with every call.

376
00:11:27.900 --> 00:11:28.860
But there is a problem.

377
00:11:29.900 --> 00:11:31.980
Once you create a token

378
00:11:31.980 --> 00:11:34.460
and you give it to the user.

379
00:11:34.460 --> 00:11:36.060
Now technically you don't have

380
00:11:36.060 --> 00:11:37.580
any control on the token, right?

381
00:11:37.580 --> 00:11:38.740
He is logged in.

382
00:11:38.740 --> 00:11:40.300
You get it now because see, when

383
00:11:40.300 --> 00:11:41.460
you were doing session based

384
00:11:41.460 --> 00:11:43.500
authentication, if you want to log

385
00:11:43.500 --> 00:11:45.620
out a user, you can just delete

386
00:11:45.620 --> 00:11:47.520
his session from the database.

387
00:11:47.520 --> 00:11:49.160
But now once you give a token to

388
00:11:49.160 --> 00:11:51.520
a user, there is no way going back.

389
00:11:51.520 --> 00:11:54.040
You get it now the token is with him.

390
00:11:54.040 --> 00:11:56.000
How will you invalidate this token?

391
00:11:56.000 --> 00:11:57.720
So ideally the best practice is that

392
00:11:57.720 --> 00:11:59.920
you should not create long tokens.

393
00:11:59.920 --> 00:12:01.240
You can just create a token

394
00:12:01.240 --> 00:12:02.800
which is for one minute.

395
00:12:02.800 --> 00:12:04.760
And if it is expired, you can

396
00:12:04.760 --> 00:12:06.560
just regenerate a token for him.

397
00:12:06.560 --> 00:12:08.040
You can just regenerate a token

398
00:12:08.040 --> 00:12:09.760
for him for one, one minute.

399
00:12:09.760 --> 00:12:11.400
And if you don't want, if you want

400
00:12:11.400 --> 00:12:13.000
the user to be logged out, just stop

401
00:12:13.000 --> 00:12:14.560
regenerating the tokens for him.

402
00:12:15.070 --> 00:12:17.750
See what happens is the worst

403
00:12:17.750 --> 00:12:19.430
case is that he will be still

404
00:12:19.430 --> 00:12:20.710
logged in for one minute.

405
00:12:20.710 --> 00:12:21.790
That's the thing.

406
00:12:21.790 --> 00:12:23.030
And you might be thinking,

407
00:12:23.030 --> 00:12:23.910
I can store this particular

408
00:12:23.910 --> 00:12:25.070
token in the database.

409
00:12:25.070 --> 00:12:26.230
You should never store

410
00:12:26.230 --> 00:12:27.550
the tokens in the database.

411
00:12:27.550 --> 00:12:30.110
But yes, you can maintain a database

412
00:12:30.110 --> 00:12:31.510
of, you know, blacklisted

413
00:12:31.510 --> 00:12:33.550
tokens, okay, where you can

414
00:12:33.550 --> 00:12:34.870
store the token of the, you know,

415
00:12:34.870 --> 00:12:35.990
which you want to invalidate.

416
00:12:35.990 --> 00:12:37.910
But the problem is again you will end

417
00:12:37.910 --> 00:12:39.070
up in the same problem.

418
00:12:39.070 --> 00:12:40.550
That is you are making a lot

419
00:12:40.550 --> 00:12:42.040
of database calls.

420
00:12:42.040 --> 00:12:43.840
So the decision is yours, that

421
00:12:43.840 --> 00:12:45.480
if you are making an application

422
00:12:45.480 --> 00:12:46.680
where authentication is very

423
00:12:46.680 --> 00:12:48.360
sensitive, like banking,

424
00:12:48.360 --> 00:12:49.880
there you should always implement

425
00:12:49.880 --> 00:12:51.480
a session based authentication.

426
00:12:51.480 --> 00:12:52.960
But if you are just building a

427
00:12:52.960 --> 00:12:55.120
SaaS where it's okay to log in a

428
00:12:55.120 --> 00:12:57.600
user for a couple of seconds

429
00:12:57.600 --> 00:12:59.320
right there, the token based

430
00:12:59.320 --> 00:13:00.600
authentication is used because

431
00:13:00.600 --> 00:13:03.280
it leads to less overhead on the

432
00:13:03.280 --> 00:13:03.960
database.

433
00:13:03.960 --> 00:13:04.560
Okay?

434
00:13:04.560 --> 00:13:05.560
So it's a balance

435
00:13:05.560 --> 00:13:06.920
between both of them.

436
00:13:06.920 --> 00:13:09.080
So you should always create tokens

437
00:13:09.080 --> 00:13:11.550
with less expiry time.

438
00:13:11.550 --> 00:13:12.870
So expires in one minute.

439
00:13:12.870 --> 00:13:14.430
And as soon as the token expires you

440
00:13:14.430 --> 00:13:16.110
can regenerate the token for him.

441
00:13:16.110 --> 00:13:17.830
So this is basically how the token

442
00:13:17.830 --> 00:13:19.550
based authentication works.

443
00:13:19.550 --> 00:13:20.670
So congratulations.

444
00:13:20.670 --> 00:13:21.590
Now you know both of

445
00:13:21.590 --> 00:13:23.550
the authentication methods, that is

446
00:13:23.550 --> 00:13:25.150
Session based authentication

447
00:13:25.150 --> 00:13:27.010
and GWT based authentication.

448
00:13:27.950 --> 00:13:29.310
This is stateless.

449
00:13:29.310 --> 00:13:30.110
This is what?

450
00:13:30.110 --> 00:13:31.390
Stateless.

451
00:13:31.390 --> 00:13:33.630
Why is this known as, stateless?

452
00:13:33.630 --> 00:13:34.030
Because.

453
00:13:34.990 --> 00:13:37.260
Because the data is stored

454
00:13:37.260 --> 00:13:39.500
inside the token and session

455
00:13:39.500 --> 00:13:41.260
based is basically stateful

456
00:13:41.260 --> 00:13:43.180
because the actual data lives

457
00:13:43.180 --> 00:13:45.180
on the server or on the db,

458
00:13:45.180 --> 00:13:46.860
so that is the whole thing.
