WEBVTT

1
00:00:00.880 --> 00:00:02.160
In the world of Python, we

2
00:00:02.160 --> 00:00:03.800
also have a concept known

3
00:00:03.800 --> 00:00:05.360
as infinite generators.

4
00:00:05.360 --> 00:00:06.560
I tend to use them very

5
00:00:06.560 --> 00:00:07.840
less, but there are always

6
00:00:07.840 --> 00:00:09.200
a use case for them.

7
00:00:09.200 --> 00:00:10.360
And especially with the world

8
00:00:10.360 --> 00:00:12.200
of AI coming in, they're actually

9
00:00:12.200 --> 00:00:13.600
getting used quite a lot.

10
00:00:13.600 --> 00:00:14.640
Let me walk you through with

11
00:00:14.640 --> 00:00:16.079
the code, because code is much

12
00:00:16.079 --> 00:00:18.520
easier way to understand this.

13
00:00:18.520 --> 00:00:19.800
So we'll just directly go

14
00:00:19.800 --> 00:00:21.600
ahead and write the code for it

15
00:00:21.600 --> 00:00:23.200
should be easier for you.

16
00:00:23.200 --> 00:00:25.920
Let's go ahead and create a new file.

17
00:00:25.920 --> 00:00:28.930
Call this one as 02/

18
00:00:29.490 --> 00:00:34.130
infinite generators py.

19
00:00:35.250 --> 00:00:37.250
All right, so how does an infinite

20
00:00:37.250 --> 00:00:39.010
generator works and where

21
00:00:39.010 --> 00:00:40.370
is it actually useful?

22
00:00:40.370 --> 00:00:42.410
It's really useful for the streams

23
00:00:42.410 --> 00:00:43.729
as well as the real time

24
00:00:43.729 --> 00:00:45.490
systems that where the constant

25
00:00:45.490 --> 00:00:46.850
updates needs to go on.

26
00:00:46.850 --> 00:00:48.450
Or maybe you want to constantly keep

27
00:00:48.450 --> 00:00:50.210
on getting this as a log value.

28
00:00:50.210 --> 00:00:51.810
They have their use cases as well,

29
00:00:51.810 --> 00:00:53.250
but use them very cautiously.

30
00:00:53.920 --> 00:00:54.680
They can actually drain

31
00:00:54.680 --> 00:00:55.560
the memory as well.

32
00:00:55.560 --> 00:00:56.920
You need a really good memory.

33
00:00:56.920 --> 00:00:58.200
But be careful with that.

34
00:00:58.200 --> 00:00:59.360
They have their use case.

35
00:00:59.920 --> 00:01:05.200
Let's call this one as infinitechai.

36
00:01:06.320 --> 00:01:07.520
So how can we actually

37
00:01:07.520 --> 00:01:08.960
generate infinite chai?

38
00:01:08.960 --> 00:01:10.280
No, we are not going to generate the

39
00:01:10.280 --> 00:01:12.360
infinite chai, but let's just say we

40
00:01:12.360 --> 00:01:14.200
want to simulate a model where once

41
00:01:14.200 --> 00:01:17.000
you buy a T, one cup of it, you can

42
00:01:17.000 --> 00:01:18.640
get a refill as many times as you

43
00:01:18.640 --> 00:01:18.800
wish.

44
00:01:18.800 --> 00:01:19.560
But we are going to keep

45
00:01:19.560 --> 00:01:20.680
noticing that, okay, we

46
00:01:20.680 --> 00:01:23.840
are having, the refills.

47
00:01:23.840 --> 00:01:25.000
So I'll create a variable

48
00:01:25.000 --> 00:01:27.280
and we'll call this one as count.

49
00:01:27.280 --> 00:01:29.200
And count, the initial value is one

50
00:01:29.200 --> 00:01:31.120
because we are pouring this one.

51
00:01:31.120 --> 00:01:32.400
And then we simply go ahead

52
00:01:32.400 --> 00:01:35.200
and say that we have a true loop.

53
00:01:35.200 --> 00:01:37.760
While true is a very dangerous loop,

54
00:01:37.760 --> 00:01:39.280
it keeps on running.

55
00:01:39.280 --> 00:01:40.040
But we're going

56
00:01:40.040 --> 00:01:41.240
to control this a little.

57
00:01:41.240 --> 00:01:42.400
We'll just say we are going

58
00:01:42.400 --> 00:01:44.480
to yield a simple value which

59
00:01:44.480 --> 00:01:45.520
will say just like return,

60
00:01:45.520 --> 00:01:47.680
we are going to say refill.

61
00:01:48.280 --> 00:01:49.640
And with the refill we can

62
00:01:49.640 --> 00:01:51.920
actually use the number of how

63
00:01:51.920 --> 00:01:53.160
many times we are refilling.

64
00:01:53.160 --> 00:01:54.680
So we'll just say count.

65
00:01:54.680 --> 00:01:57.120
And once we actually refill this,

66
00:01:57.120 --> 00:01:58.640
then we simply come up here

67
00:01:58.640 --> 00:02:00.840
and say count plus equals one.

68
00:02:00.840 --> 00:02:02.760
So we are adding a value to it.

69
00:02:02.760 --> 00:02:03.880
I like this one.

70
00:02:04.680 --> 00:02:06.400
Now this is a very dangerous thing

71
00:02:06.400 --> 00:02:08.440
to write if it would be general

72
00:02:08.440 --> 00:02:10.080
return statement or anything there.

73
00:02:10.080 --> 00:02:11.880
But since we are yielding, we are

74
00:02:11.880 --> 00:02:13.640
not troubling the memory that much.

75
00:02:14.240 --> 00:02:15.640
So I can just go ahead and say, hey,

76
00:02:15.640 --> 00:02:17.560
I want a refill and I will have

77
00:02:17.560 --> 00:02:19.600
an infinite child just like this.

78
00:02:20.480 --> 00:02:22.880
Now let's just say I don't want to

79
00:02:22.880 --> 00:02:24.280
use this variable, so I'll just

80
00:02:24.280 --> 00:02:25.920
use an underscore in this one,

81
00:02:25.920 --> 00:02:27.880
remember I told and discuss about

82
00:02:27.880 --> 00:02:29.520
this a little bit that when you

83
00:02:29.520 --> 00:02:30.880
don't want to use this value

84
00:02:30.880 --> 00:02:32.320
itself, you can just write an

85
00:02:32.320 --> 00:02:32.760
underscore.

86
00:02:32.760 --> 00:02:34.560
It fills the syntax but we

87
00:02:35.280 --> 00:02:37.040
tend to avoid creating

88
00:02:37.040 --> 00:02:38.960
an unnecessary variable.

89
00:02:38.960 --> 00:02:40.560
It helps in linting as well.

90
00:02:41.380 --> 00:02:42.860
So let's just say we go for a range

91
00:02:42.860 --> 00:02:44.580
of 3 till the value is 3.

92
00:02:44.580 --> 00:02:45.780
We keep on going with that

93
00:02:45.780 --> 00:02:47.820
and simply go ahead and print.

94
00:02:47.820 --> 00:02:49.020
I cannot just go ahead

95
00:02:49.020 --> 00:02:50.500
and print the refill because

96
00:02:50.500 --> 00:02:51.860
that's not how it works.

97
00:02:51.860 --> 00:02:52.980
I have to use the next

98
00:02:52.980 --> 00:02:54.980
keyword and here I will

99
00:02:54.980 --> 00:02:56.580
have to call the refill.

100
00:02:56.580 --> 00:02:57.380
There we go.

101
00:02:57.380 --> 00:02:58.340
This is how you write

102
00:02:58.340 --> 00:02:59.180
the infinite child.

103
00:02:59.180 --> 00:03:00.740
Let's go ahead and run this

104
00:03:00.740 --> 00:03:02.260
and clean this.

105
00:03:02.260 --> 00:03:04.580
We'll say Python 302

106
00:03:04.580 --> 00:03:05.660
infinite generator.

107
00:03:05.660 --> 00:03:07.370
Notice it this time we are

108
00:03:07.370 --> 00:03:08.770
controlling it, but it's

109
00:03:08.770 --> 00:03:10.130
refill as much as you want.

110
00:03:10.130 --> 00:03:12.690
So we are having a refill 1, 2 and 3.

111
00:03:12.690 --> 00:03:14.170
And again this is a little bit

112
00:03:14.170 --> 00:03:16.610
awkward of a new style of writing

113
00:03:16.610 --> 00:03:18.370
Python, but this is generators

114
00:03:18.370 --> 00:03:19.810
and this is infinite one.

115
00:03:19.810 --> 00:03:21.610
So you can run them as many time

116
00:03:21.610 --> 00:03:23.250
and you are controlling them.

117
00:03:23.250 --> 00:03:24.650
Notice here this loop doesn't

118
00:03:24.650 --> 00:03:25.450
tell you that you have

119
00:03:25.450 --> 00:03:27.410
to stop for 1 or 5 or 10.

120
00:03:27.410 --> 00:03:28.250
This is how we are

121
00:03:28.250 --> 00:03:29.570
controlling the range.

122
00:03:29.570 --> 00:03:30.490
This is going to just

123
00:03:30.490 --> 00:03:31.130
keep on printing.

124
00:03:31.130 --> 00:03:33.000
You have an infinite coupons

125
00:03:33.000 --> 00:03:34.600
printing machine or infinite

126
00:03:34.600 --> 00:03:36.280
refill station that you have

127
00:03:36.280 --> 00:03:37.560
it always keep on getting.

128
00:03:37.560 --> 00:03:39.040
And since we have a while true

129
00:03:39.040 --> 00:03:40.840
and yield, as long as the same

130
00:03:40.840 --> 00:03:42.240
guy is going to call it, it will

131
00:03:42.240 --> 00:03:43.880
keep on working with that.

132
00:03:43.880 --> 00:03:45.880
The advantage of this is now

133
00:03:45.880 --> 00:03:47.120
I can just work with this.

134
00:03:47.120 --> 00:03:49.760
Let's just say this is another client

135
00:03:49.760 --> 00:03:52.920
that comes up or user2 and that

136
00:03:52.920 --> 00:03:55.640
user2 also uses the infinite chai.

137
00:03:55.640 --> 00:03:56.600
There we go.

138
00:03:56.600 --> 00:03:58.240
Now we are keeping a track

139
00:03:58.240 --> 00:04:00.050
of both the objects set separately

140
00:04:00.050 --> 00:04:01.090
with the same function.

141
00:04:01.090 --> 00:04:02.490
So that's really interesting.

142
00:04:02.490 --> 00:04:04.770
So for underscore in range,

143
00:04:04.770 --> 00:04:06.210
let's just say this guy gets

144
00:04:06.210 --> 00:04:08.930
a six cup of refills and I can

145
00:04:08.930 --> 00:04:10.650
just go ahead and say print.

146
00:04:10.650 --> 00:04:12.250
I have to use next

147
00:04:12.250 --> 00:04:14.730
and this time this is user 2.

148
00:04:16.010 --> 00:04:17.890
So both of our user gets this

149
00:04:17.890 --> 00:04:19.450
value and they are separately

150
00:04:19.450 --> 00:04:20.649
just working with that.

151
00:04:20.649 --> 00:04:22.450
So notice here, first we are

152
00:04:22.450 --> 00:04:25.570
running 1, 2 and 345 so this is

153
00:04:25.570 --> 00:04:27.600
for the top one and then

154
00:04:27.600 --> 00:04:29.200
this guy gets a six refill.

155
00:04:29.200 --> 00:04:30.400
So we get all the six

156
00:04:30.400 --> 00:04:31.480
value being refilled.

157
00:04:31.480 --> 00:04:32.800
Pretty interesting, isn't it?

158
00:04:32.800 --> 00:04:35.360
It's not intermixing the values

159
00:04:35.360 --> 00:04:36.800
but it works nicely.

160
00:04:36.800 --> 00:04:37.600
So that is it.

161
00:04:37.600 --> 00:04:40.160
These are your infinite generators.

162
00:04:40.160 --> 00:04:41.360
Hope they were fun.

163
00:04:41.360 --> 00:04:42.880
Let's catch up in the next video.
