[
  {
    "id": "02_Subtitles___Auth_Sec_01_Authentication_vs_Authorization_vtt_01_Authentication_vs_Authorization_vtt",
    "content": "Hi everyone and welcome to brand new section on authentication and authorization. So personally this particular section is very exciting and I personally love this particular section. Authentication and authorization is a core concept of any backend system, right? And sometimes authentication and authorization can be very tricky or hard to understand. But, but no worries. In this particular section we are going to go step by step. We are going to understand each and every bit of authentication and authorization and how in Node js we can build a secure authentication workflow. So in this particular video, let's first understand the meaning of these two words that how authentication and authorization are two different things. Okay, so here we are talking about authentication, which is our first word, right? That is authentication. And secondly we have authorization. Now knowing the difference between these two things is very important. Okay, so let's first understand what is authentication, right? Authentication basically means that who are you? In simple terms, authentication means who are you? Do I know you? That is an authentication. Okay, so which means like for example, if you go on to facebook. com, right? If you are not logged in, you are welcomed with a login screen. Okay? So whenever you open facebook. com if you are not logged in, you are welcomed with a login screen. For example, if I open a new tab and I go onto facebook. com so what you will notice is see, I am viewing this page. That is a, login page. Why am I seeing this page? Because I am not authenticated. The server is not able to recognize me. So that means let's say if we have a server here, okay? So let's say this is our server. This is the Facebook server, not my server. So what is basically happening here is the server and I am a user, right? So let's say here is the user. So this user that is me, I made a request to the server and server says hey, I don't know who are you, right? It is not able to recognize me. And that is the reason the response from the server was a slash login page, which is nice. Now the thing is, this particular thing means that this particular user is not authenticated, server is not able to recognize me. On the other hand, let's say if I am logged in, okay, so if I give him my email and password and somehow I am logged in, that means that if I send a request to the server in, instead of getting a login screen, what I, what do I get? I get basically all my feed, okay? I get feed posts, I get all my friend requests, I get all that data, right? I am able to get my data so that is what that means. I am authenticated. I am authenticated. That means server is able to recognize me that, oh, this is Piyush Garg. And based on who am I Based on like my id, like, let's say Piyushkar. It is sending me the post that is relevant to me. It is sending me the friend request that are being sent to me. It is sending me my messages, my messenger, my groups, everything, mine. Okay, so this is basically authentication. That means whether you are logged in or not, if you are authenticated, okay, you are an authentic person. I know who are you? But what is this? Authorization. So authorization is basically the next step of the authentication. Authorization says that it. It assumes that you are already authenticated. But are you authorized? Are you authorized? Okay. To this resource? Okay, now what does this mean? I'll just give you an example and everything will be super clear. Let's say this is your college. Okay? This is your XYZ college. Okay, that's good. Now, first thing is, can a random person. Okay, let's say here is a random person. Can a random person enter, the campus of the college? No. Right? Why? Because there is a security guard sitting here. So let's say that this is your security guard. So this security guard, whenever you try to enter, you are not. You are not allowed to enter because he doesn't recognize you, right? You are just a random person. You have no ID card. You don't have any kind of thing, so you are not allowed. That means you are not authenticated. So your authentication failed. But let's say you had. You have taken the admission in this college. And in return, college has given you something known as an ID card. So whenever you go, you submit your fees, right? You pay your fees and you get admission. You are given an ID card. Nice. Now, this ID card, which is issued by this XYZ college. Now you take this ID card. Now you as a person, go back to the security guard. Show your ID card. Now you are authenticated. Should this security, guard allow you to enter the college? Yes. Why? Because you were authenticated. Nice. Now, let's say this is print. This is your classroom. Okay? So let's say this is your classroom. So I'll just draw it in this way. And, let's say this is some internal staff room. Okay? So let's say this is the staff room or principal's room or some kind of internal room in your college. So I'll just make it green. Now, based on this ID card and you are a student, can you Enter this particular class? Yes, you can enter. Because that particular class is meant for you, right? That's a class. You can enter it. But with this ID card and this thing, can you enter in the staff room? No, right? Why? Because again, there will be one more security guard, let's say in front of the staff room. But to enter here, to enter here, you are not allowed. Why? Because your ID card says that you are a student. And as a student, you are not allowed to enter the staff room. But on the other hand, let's say one more teacher is there. Okay? Now, teachers also have their ID cards. But this ID card holds an authority of a teacher. Okay, Of a teacher. Now first of all, tell me, should this particular person be allowed inside the campus? Yes, because they have an ID card, they are authenticated. Now, when they come here, this person will check that, Hey, I know that you are already a part of this college, because if you were not a part of this college, anyway, you cannot bypass this gate. But now I have to check whether you have authority to enter the staff room or not. So it will. So this security guard will check. Oh, I see that you are a teacher. Your role is a teacher. So I think you are allowed. So this particular teacher can go into the staff room, but not this ID card. So this is basically authorization, okay? That are you authorized to this particular resource? So authorized is the word here. Okay? So that means for authorization, you have to be authenticated. This is simple, right? Because for authorization to work, you should be authenticated. Authenticated means you are logged in. The server knows who are you, right? You have some kind of ID card. But authorization means. Authorization basically means are you allowed to access that resource or not? Got it. Now if I log into Facebook, I am authenticated. But can I access your friends? Can I accept a friend request that is sent to you? Of course not, because I don't have authenticity, I don't have that authorization to accept a friend request or on your behalf. Got it? Now can I change your password? No, because I am not authorized to do it. So that is, your authorization. So I hope the difference between authentication and authorization is clear. So first step will be authentication, understanding authentication and everything. Authorization is very simple, to be honest. Once authentication is clear, authorization is nothing. It's just a check. Okay? The main challenge, the main security comes in the authentication which we are going to cover in the upcoming videos.",
    "metadata": {
      "course": "02 Subtitles - Auth&Sec",
      "chapter": "01 Authentication vs Authorization.vtt",
      "filename": "01 Authentication vs Authorization.vtt",
      "originalPath": "02 Subtitles - Auth&Sec/01 Authentication vs Authorization.vtt",
      "type": ".vtt"
    }
  },
  {
    "id": "02_Subtitles___Auth_Sec_02_What_is_Authentication__Story_Time_vtt_02_What_is_Authentication__Story_Time_vtt",
    "content": "All right, so in this particular video, I have a story for you now, Piyush. But we were here to understand authentication. Why there is a story. You know what happens? I am a kind of person who don't, likes to understand things by just coding, right? We should understand what we are coding. The, what is the logic behind it? What is it, how that idea was invented. Okay? Because coding is the simplest thing and at the end thing that we have to do. So let's understand the authentication. Now there was one more story that I have just shadcn with you that was XYZ College. So this particular thing, I think this particular story or this particular visual representation helped you in understanding what authentication and authorization is. Now let's understand authentication. Little bit in deep and some challenges that might occur. Okay? Now see there, this is a story of a parking lot. So let's say that this particular area, this particular is a parking lot. So what is a parking lot? Parking lot is an empty big space where a lot of a lot of vehicles can come and park themselves. Right. Now technically this parking lot is let's say a paid service, okay. Or a private owned service by some kind of mall. And you don't want that anyone can come and park in this parking lot. So what will you do? You will basically hire a security guard. So, so let's say that this is the gate and this is your security guard. Or I can say the valet parking. So you have, basically you have a security guard here. So if anyone wants to park a car, no one has access to here, right? What you have to do is let's say this is the person with his car. So let me just try to draw a very basic car. So a green color car. I don't know why I came up with green color. But I think yeah, this is okay. Okay, so one more thing I'll just try to do. So let's say that this is your car. Okay? I didn't know that. I am such a good artist, but yeah. Now let's say this is a car, okay? And this is the owner of the car. Now this owner of the car wants to park his car in this parking lot. So what will happen is he will come to the security guard and he will say that, hey, can you please park my car? Security guard will say that, okay, there is a space available. I'll park your car. So let's say that the number of this particular car, okay, let's give it a number, was, let's say something like, you know, X, X1, Y so this was the number of the car. So what this particular guy will do is he will park his car. Okay? So his car is parked. Now, in return, he needs some kind of receipt, right? He needs some kind of token, right, that, hey, you parked my car. But when I will come back, how can I tell you which was my car? Because if we just say him tell me your number, he might say any other number. Imagine coming in Honda City and going back in Mercedes. That's not a right thing, right? So what this security guard can do is security guard can basically give him a number. So let's say security guard said, hey, here is your token. Basically a token. Let's say a number is written even. Okay, I'm just taking a random example of E So what now this, this particular person can do is. But this particular person can maintain a diary. Okay, typical. How happens he can maintain a diary. Okay, so let's say this is the diary. And in this diary he can make an entry that E1 token belongs to XX1Y car. Okay? Now this person can go roam around, you know, he can go to shopping, he can basically enjoy himself. And when he comes back, what happens? He has to give his token back. That, hey, here is my token, E1 that you gave me. Can you give me my car? And then security guard will say, okay, let me check. He will open his diary. He will see E1 was this car. So he will, he will take the token back, give him his car, and delete his entry. Is this flow clear? Typically how this basically happens in the real world. Also, whenever you go, you give your car, you get a, token which uniquely identifies your car. Some kind of number you get, right? So let's say this is one. Let's say more users are coming. Okay, so. So one more user is there. One more user is there. One more user is there. So what is happening is you are getting different, different tokens. So everyone is getting a token. So let's say E3, E And now we have a lot of cars in the parking lot. So these are the cars parked. And let me just, quickly rename their, you know, numbers. So let's say this is E2, this is, you know, this is the three three number. And this car has a number of four. Okay, now what happens? You have four entries in your, in your book, in your, diary, whatever you are maintaining. So E2 is there, right? Which is having a number, let's say E2Y. Then you have so on. So you got the point. Now tell me just one thing. I just want to understand from you, okay, how open minded you are. Do you see any problem here with this approach? Everything is working fine. Everything is secure, right? There is no problem at all. Everything is secure. We are doing every kind of check. We are maintaining a diary, and our security guard is working really nice, okay? He is a very hardworking man. But what problem could come here? Can you think of a problem here? Okay, now let me come back with the problem. Number one. What happens if there is a sale in the mall? Let's say there's a lot of rush, a lot of people came in. You know, on a typical day, there were just 30, 40, users or members or, you know, users, coming in. But some day came in. So what will happen? This security guard will be overwhelmed because now he has to do Now, because you just had one security guard, what you have to do is he has to do one by one. Number one, he's tired, okay? He is tired. That means he can basically, you know, get a heart attack or he can collapse, right? So technically, there's a lot of stress on one person. Secondly, he has to do one by one. So that means if someday people came in, they have to wait in a long queue because you only had one resource. See, there is a thing that your parking lot can support cars, okay? That is fine. You have enough space. But because you just had one security guard, now he, now there is a long queue of people, which is not a good experience, right? Because he is doing one by one, one by one. And so how can you solve this problem? You will say, push. It's very simple. What I can do is I can basically have three security guards. You will say that because too many people are coming. So what I will do is I'll make three lines. Okay, so one, two, and one more. Security guard. I said, very good. This is a good optimization. Now you have divided the traffic into three lines. And what is happening is you are basically processing three cars concurrently, correct? Parallelly, I would say. Parallelly, you are processing three cars, okay? So now your processing speed is faster. But now there is a problem because there is only one diary. Because there is only one diary. When this person is writing to this diary, can this person also write to the diary? No. Right? Because there is only one diary. So technically, what happened? Even if you have three security guards, or even if you have four security guards, the major problem still remains that at a time you can only process one car. Because if this Person is busy entering some entry here. These three are waiting for the notebook to get freedom, right? So still you are only processing one notebook at a time. The only thing is that the stress per. What do you say? That the per security guard is reduced. But still the line is very long. So you will say, okay, no problem. To solve this particular problem, let's have four diaries. No. Hey, you have your own independent diary. You have your own independent diary. You have your own independent diary. And you also have your own independent diary. Now there is no one shadcn diary. I said okay, which is very nice. Right? Now they are not dependent on each other. So what happens is he can keep on entering. So this particular guy can keep on entering stuff here. This particular can keep on entering stuff here. This here, and this here. Now you have solved all the problems very nicely. I mean, you are processing four cars parallelly, which is like four times. And no one is dependent on each other, which is nice. Now here comes a problem. Let's say this person, when came for parking, he gave to this guy, okay? So that means the entry for E2 is in this particular diary. Now what happens when he comes back to take his car? He accidentally comes here to this guy, he will say, hey, My token is E Can you give me my car? Is there any E2 entry in this particular diary? No, right? Because that. That entry is here. So technically this person will say, sorry, bro, I don't know who are you. I don't have any entry for E So I cannot process your request. I cannot validate whether your car, which is your car. So that means this guy has to remember that. Hey, when you came for parking, you have given to this security guard, security guard number. Let's say four. So when taking back the car, you have to come to four. You cannot go to E1, you cannot go to security guard one, two or three. You have to come back to the same person, which is a problem, right? He has to remember something. And tell me just one thing, what happens? Okay, if everyone parked their car with person four, now these three are sitting idle. Because everyone parked their car to number four. While taking back, also they have to come to four. So that means four is always under stress, right? For some reasons, 1, and are busy. Plus people have to remember that. Hey, if I have given my car to person number four, I have to take back from him. So this is a big problem, right? You're trying to understand the problem, right? See, we are not talking about authentication. We are not talking about authorization. I'm just telling you a story. Everything will eventually make sense. Now, how will you solve this particular problem? So, problem came that when you distributed their diaries, okay? When you distribute their diaries, now you have to remember which person is having which thing. So this is basically what happened. What I'm trying to tell you is that initially, when you just had one security guard, okay? Let's note down our observations. When you had one security guard, okay, security guard, or I could say the park person. You had only one diary, okay? Only one diary. And what you were doing is you were basically giving them tokens. You were giving them tokens and everything was good. The pros were okay. The pros were number one because there was only one security guard. No need to remember. No need to remember. Okay? Which guard parked your car? Which is nice. You can just come back, okay? Secondly, the problem was, secondly, the cons, okay? Con was, okay? The problem was that there was only. Only one guard, okay? So speed was very slow. So speed was a problem. Speed was slow, okay? Plus a lot of stress. Only on one person. Only on one person, okay? And, so, yeah, this. This was basically what was happening in the first scenario, right? Nice. Then to solve the cons of this particular thing, what it did do, you basically had the. Another architect that, hey, I will have four security guards but only one diary, okay? So the pro was, okay, what did you solve? You basically solved this problem, okay? You solved this particular problem. So I'll just say, hey, this particular approach solved this particular problem. A lot of stress, okay? But still, there was one con. What? That at a, given. At a, given time, only one person has access to diary. So which basically makes it still slow. Got it. Now, because, if one person is writing to a diary, the all others cannot write to it. Okay? This was your approach too. See, this was your approach. One, you got the problem. Okay? So you solved it, but you got another problem. So to solve this particular problem, what did you do? You basically said, okay, I'll just do one thing. Four security guards. That means four diaries must be there, okay? That means four diaries. Everyone has their, independent IDs. Now, if I talk about the pros of this thing, what did you solve? You basically solved this particular problem. You solved this particular problem, which is nice. See, at every step, you are solving one problem at a time, right? So solved this particular problem that at a given point of time, only one person has the access. But now you introduce one more con. Now you introduce one more con. What was the con? The con was that hey, the you know, the Parkers, or I can say the customers have to remember, have to remember which was the guard while parking, okay? Because you have to go to the same person in which your diary was maintained, right? In which, in which your car's diary is maintained or in which diary or cars entries maintain. You have to go to the same person. Because if you go to some other person in his diary, there is no entry for your car. So that's a problem. Now technically, if you see about authentication, what we are going to do is now we are going to first implement this kind of authentication. One server, one state, okay? Diaries basically state. And we are going to end up in this problem. Then we are going to solve this problem and I'll show you the another problem. Then I'll going to say that hey, how horizontally scaling is a problem. But in this particular video I just wanted you to visualize what is happening as per your life. Okay? So in the next video, let's go ahead and code this stuff, code this stuff and code this stuff and then finally solve all the problems in just one go. Okay? So that is the thing. So I hope that you have understood the story and the problem behind it. Now how to relate it with the authentication. That's my problem that we are going to see in the next video.",
    "metadata": {
      "course": "02 Subtitles - Auth&Sec",
      "chapter": "02 What is Authentication- Story Time.vtt",
      "filename": "02 What is Authentication- Story Time.vtt",
      "originalPath": "02 Subtitles - Auth&Sec/02 What is Authentication- Story Time.vtt",
      "type": ".vtt"
    }
  },
  {
    "id": "02_Subtitles___Auth_Sec_03_Session_Based_Auth_vtt_03_Session_Based_Auth_vtt",
    "content": "All right, guys. Hi. So, in this particular video, let's start by coding a basic authentication system using the story one, then improving it with story two, and further improving it with story three. And finally the last set of the story, how we can make it fully optimized. Okay, So I have made a very simple project that is authentication So first things first, npm init in your integrated terminal. Right. So authentication I'll just do enter, enter, enter and enter. Everything is good. So let's install couple of things. Right? npm install express is first thing. And please do mention at the rate Okay. point x, because you know, we want to install express at so that you don't get into any trouble. Nice. Now because we also want typings. Okay, we also want typing. So I'll just say npm install at the rate types node at the rate types express at so that I can get the IDE recommendations. And don't forget to save it as a dev dependency. So after this particular command, this is what my package JSON looks like. So you can see in the dependencies, I only have Express at this particular version. I have dev dependencies at, this particular version and this particular version. Nice. Now let's get started by creating an index js file. So first things first, I just want to basically create an express server. Okay. So I can just say import. Okay, Import express from express. Nice. Then I can just create an app which is express. Okay, that's also good. And let's create a port also. So const port, is equals to I. I'll just say 8, that is okay. And app dot listen. On which particular port? This particular port. And. And a callback function saying console log. Let me just zoom in a little bit for you so that you can see this clearly. Right. I hope this is fine. So console log. And I can just say, you know, server started on port and just add the port here. Nice. Now what is the next step? Let's create some routes. Okay. Now, as a part of authentication, of course, you need a login route, right? So what do you mean by login? Login basically means that you are going to give me your username password. That means you are trying to authenticate. You are bringing back a token. Okay, I'll create one more route. Let's say, you know, sign up. Okay, let's say sign up. So this is, is going to be your sign up route. And sign up is basically like, you know, taking your car and parking it creating a new car sign up. And I'll just create one more route that is me. Me basically returns that. Who are you on the server? Can I recognize you or not? Is going to be the me route. So now see what we are going to do is app dot get. Okay, first let's sorry app dot post. Let's create a route that is sign up. Okay? Now what is the sign up? Sign up basically means that hey, here is my car. Here is my car, okay? Please park it and give me back a token that is your sign up, correct? That is how you sign up. So in the sign up, okay, one, what will you give me? Okay, so what are you going to give me? You are going to give me your credentials. Okay, so a callback function. So I'll just say hey, this is request, this is a response. So I'll just take some data from the request body. What, what I want, I want. Okay, when you bring your car basically your data, I want your first name, okay? And let's just call it as name. And you can give me your email and you can give me your password. So email is basically like your car's number. Okay, Just for the analogy. So I'll just make a new comment. So email is basically like a unique car number, right? So in order to have this, what I will do understand this thing. This is very important, correct? First of all, I have to do one thing that is a middleware app dot use, okay? App dot use that is express dot JSON because we are going to talk in the JSON format. Now what I can do here is if you think about it, I have to create a user, right? Basically I need my diary. Okay? Const diary. Eventually it can be a database also. But as of now let's go with this thing diary. So what I can do is first of all check that if this particular email is already in the diary. If email in diary this means you are already signed up, right? So you can just say return response status of a and you can just say JSON and return an error that a user with account Or I can just say user, email already taken. So this particular email is already in the use. Else what will you do is let's create a token for this user. Let's create a token for this user, right? So what I. How can you create a token for this particular user? Tell me that. Okay, So I can just say I'll just use date. now so this basically returns what is my current date so that is a token. Simple. Okay. Ideally it should have to be some kind of id, but this is my id let's say. Okay, now here is the one thing that I have done wrong. Let's create a diary and let's create a new set of emails which are already taken. So emails is basically going to be a new set. Okay. Okay, so let's say if emails dot has okay, this particular email. Now if it is not there, what I'm going to do is I'm going to just say hey, in my diary, in my diary at this particular token, whatever you have created, I am going to say hey, this is your name, this is your email and this is your password. Okay, I have basically made a diary entry. Okay, so create a token for user. A token for user. Okay, I have made a token and then I can just say do a diary entry. Okay, do a entry in diary. Okay, very nice. And then, then what, what's next? One more thing also you have to say emails. add okay, this particular email and finally you can just return response. JSON saying status is let's say success. And then you can also return his token that hey, hey bro. That this is your token. Every time you have to come back, you have to come back with this particular token. Nice. So this is what I have done. This is what we basically discussed. So just see, just go through the code once what we are doing, make a diary, make email set. If user has already signed up using this email you return a new error. Else create a new token. Okay, do a diary entry, add to the email set and return the token. So this is basically what I have made which I told you here. So you take a token, you basically do a diary entry and return it back. Nice. Now let's create a route app dot get. Okay, let's say a me route slash me me is basically what that I will tell you. Who are you if you want to take back your car. It's kind of like you want to take back your car. Okay, so request and response. So whenever you come back, what I am basically saying you. Okay, now listen to this thing. Whenever you come back you have to bring your token. See now in this particular story, if any user wants to take his car back, he has to bring his token. So I'll just say that hey, in the request body you have to bring your token back. If there is no token. If no token is there? I'm just going to say return response status. Hey, it's a bad Request JSON. That error is basically missing token. Okay, Missing token, which is good. Else what I will do, I will search my diary. So I'll just say const. Okay, I'll just search for this token in my diary. If Token. Okay, in diary. So let's say if you're not able to find this, if token in diary is not there, okay, then that means, hey, you have just bought a token which is not in my id, which means you are not. This is not a valid token. Okay, you have bought a different token. So I'll just say invalid token. Invalid token. I don't have an entry. Okay, but if I have an entry, I'll just say const. Entry equals diary and add this particular token. And what I can do, I can just say return response JSON and you can just return the data as the entry that. This is what I basically store about you. That's it. So this is our me route. That's it. So this is your very simple authentication. Correct. So now if I run this particular application, how to run. So I'll just create a new start script and I'll say node index. So npm start. Okay, so everything has gone good. You can see server, is running on Port So I'll just use the Thunder client. Okay, so let me just create a new request and you can just ignore these requests. Okay, so I'll just say that. Hey, on localhost Okay. On localhost8000, on which particular thing? On slash signup. Correct? Just a second. Yeah, on slash signup. I want to make a new post request. Nice. Okay, in the body, I'm going to send a JSON there I have to send my name, which is piyush Garg. Okay. And I will send my email, okay, which is piyush piyushgur. devmail. com and also you need my password which is Right? Send. I got a token. Can you see that? This is my unique token. I'll just copy this particular token and as of now store it here. This is my token. If I send this request again, email is already taken. It's a bad request. Nice. Now let's say if I create one more new request, right? So let me just create a new request. Okay, so in this particular new request, what I'm going to do is I'm just going to take the same thing, but I'm going to make a request on slash me. Okay? Slash me. So when I send it says hey, missing Token. Okay, so that means in the body I have to send a token. So I am sending token 1, 2, It says invalid token. This is not a valid token. This was the valid token, right? So if I send this token now, you can see it says this is you. You are this particular person. So now what happened? Can. Let's say if I want to, okay, if I go back to my server, let's say what I want to do is I want to say that, you know, you want to access cars. Let's say you want to access some private data. So I can just say app get. Sorry, let's make a post out only. Okay. App dot post. So I'll just say that this is some kind of private data. Okay? This data should only be visible to persons who are logged in. Who are logged in. So what? How can I check? First of all, try to read the token. Okay, if no token or this thing see same. I'm just copy pasting the code, right? Copy pasted the same code. I'm just saying if no token, if not token in diary entry. Now what I can do, I can just say if I got the entry, then I can return you the data. So I'll just say return response JSON and I can just say the data to be what? I can just say you know, status. I can just say private data. Private data access granted. Something like this. So that means if you want to take this, right? If you want to make a request on slash private data. You can see I'm able to make a. Not able to post because I have to restart my server. Now here's a problem. Because I restarted my server, I have to sign up again, right? No worries, I'll just sign up again. This is my new token. Now if I try to access, you can see it says invalid token because this was the old token. Send private data access granted. If I will not send this, it says missing token. That means I am not logged in. I am not authenticated. So this was your very basic authentication. I mean in real world, this is not how authentication works in reality. But you have actually made a successful working authentication system on, on this principle. Okay, in reality, no worries, I'll walk you through. In reality, this diary is going to be what, a database? This diary is going to be database. Okay, now you're getting my point, right? And then you are going to generate these tokens. Got it? Okay, now coming back, what was the con? Only one guard speed was slow. Now here is a problem. See, in reality, in real world, what happens now? You don't have one server because one server cannot handle a lot of traffic. In reality, you actually spin up multiple instances of your same server. Okay. So when users come, when users tries to visit your website or server. So few requests are routed here, few requests are routed here. Some requests are routed here, some requests are routed here. So technically, if while he was logging in or he was creating an account, he redirected to this server. Now this server, basically has the token, right? In his states, in this particular diary, this server, contains it. But when he tries to access the private data, the request was routed to this particular server. So what happens? Does this server know that this token means this user? No. Right. So that is a problem. That means this particular approach is not scalable. Why? Because if, you want to go with this approach, you have to make sure you always and always have only and only one server running. Because this server maintains a state, a diary, this server contains the data. So all the requests must be handled by a single server. So this approach of making a diary and emails is not at all scalable. It is not at all scalable, right. So scalability is an issue. But if you only want to spin up one instance, then this is fine. Okay, nice. What was our second approach that I want to scale it, right? I want to have four instances of my server running, but I want to have only one diary. So in this particular scenario, what we could do is this diary can be moved to a database, yes or no? So technically what we are trying to do is, you know, drizzle, right? So let's say this is your database running, so everyone can basically connect to it, keep the tokens here, retrieve from here. But the problem is that with this approach, what will happen? You are actually making a lot of load on the database because four servers are continuously reading the data and writing the data to, diary. And while, while one is writing to something to the diary, okay, he's creating a token, others have to wait, Others have to wait. That is a problem. But to solve this problem, if you give four diaries to four security guards, again, that's a problem. You know what's a problem? Because if the diary is with this person, he has to go to this person only. He has to go to this particular server only. His request cannot be routed to some other server instance. So this is basically the problems with this particular approach. Okay, just for your knowledge, this particular thing is also known as session based authentication. It's known as a session based authentication. Why? This is known as a Session based authentication. Because what you are basically doing is now you're creating a session for a user, you are maintaining a diary for the user and you are giving him a temporary token which is stored in your database, sorry, not database, in your memory, I can say right in your ram, in your variable. So while the server is running, basically you have the access to the token that, okay, if the token is in the diary, you mark him as authenticated. So in session based authentication, what happens is basically the server becomes. The server is stateful. The server is stateful, server is maintaining a diary for you where it is keeping a record of that, which token, which token is issued to which person. Yes or no? Yes or no. This is very nice because you know what is the advantage here? I have the control, anytime I want to log out this user, I have to just delete the token in my database. So let's say if I figure out that hey, this particular user seems a hacker, so what I have to do is I have to clear my diary and all the users or that particular user with that token is automatically logged out because when he will again make the request because the token is not there, he will be considered as logout. Session based authentication. The problem is it's stateful, right? The scalability is a problem. It's not at all scalable. If you have noticed, this is really nice for short lived sessions. Can you give me an example? If you understand banking, whenever you log into your banking website, you are all, you are only logged in for a couple of minutes. They only allow you to log in for five minutes. After five minutes you are logged out. Because they use sessions, they use stateful sessions, they create a token on their server, they give you the token. But what is in that token? The data about that token is stored on the database. See, technically if you see here, this number makes no sense. This number which is my token makes no sense at all. Because the data associated with this number that, hey, the username is piyush, it is, you know, email, is this password? Is this, that data is actually stored on the data, on the server. So in this scenario you give the token to the person. Okay, but actual relevance of the token is stored on the server. That is the main thing. That is why it is known as stateful because the state is maintained by the server and it's a session based authentication. It is really nice for short lived sessions, but not for the long lived sessions. So what is used in the long lived sessions? There is something known as JSON web tokens Right. Or I can also say stateless authentication. Okay, Stateless authentication. So this is something we are going to cover in the upcoming videos as well. So let me just do one thing. In the next video, let's end to end. Okay? I'm using the word end to end. Let's end to end. Okay. As I say end to end, code a session based stateful auth system. Okay? So in the next video we are going to first code this and then we are going to jump to the JSON web tokens which is basically a stateless authentication. So I meet, I'll meet you in the next particular video.",
    "metadata": {
      "course": "02 Subtitles - Auth&Sec",
      "chapter": "03 Session Based Auth.vtt",
      "filename": "03 Session Based Auth.vtt",
      "originalPath": "02 Subtitles - Auth&Sec/03 Session Based Auth.vtt",
      "type": ".vtt"
    }
  },
  {
    "id": "02_Subtitles___Auth_Sec_04_Session_Based_Auth_with_Drizzle_ORM_vtt_04_Session_Based_Auth_with_Drizzle_ORM_vtt",
    "content": "All right guys, so in this particular video let's code an authentication system end to end, using session based authentication. I hope at this particular point. You know what is a session based authentication? Why is it known as stateful authentication? And with that let's start with the video. So here I have made a simple project that is authentication session, right? So this is what we are going to use here. And let's get started. Okay, so, so first of all what I'm going to do is I'm going to use PNPM As my package manager. So it's basically same as npm. So if you search for pnpm, it's basically a better version of npm. Okay. It works similar to npm and everything is that, but it is more fast, it has more optimal and it caches. So I would prefer that if you can also use pnpm. The installation is very simple for pnpm. So here you can see all the installation steps. For example, PowerShell on Windows is there POSIX systems are there, right? And if you go down there is a Docker container installation as well. There is, if you go down there is a core pack, installation. So there are like all the installations are there. And this is the simplest one. For example, you can just say npm install hyphen g PNPM at the rate latest. That's it. Okay. No, no need to give the version name. And you can even use Homebrew if you are on Mac. So basically you can use PNPM as a replacement for npm. So, so the command goes like PNPM Init. Basically this is same like npm init. You can see I have a package JSON file right now what we have to do is we have to basically create an end to end authentication system. That means we need database, we need all the routes. So technically it's an end to end thing. Okay, so now we are going to do PNPM install at the rate types okay, slash node and add the rate types express. Okay, slash express and save it as a dev dependency. And don't forget to make 4x. Okay. So this ensures that we are on the same version. Nice. Now we have to install express. So I can just say pnpmi and I can just say express at the rate 4x. So this basically gives me the express as well. So now you can see in my package JSON I have these dev dependencies. And I have these dependencies. Nice. So let's get started by creating an index js File. Okay, so what I'm going to do is I'm just going to say, import something from express. So basically I want to import express from express, right? Let's create an application that is express. Okay, that's nice. And let's also get the port. So let's say I want to run it on process env port. So if you give me an environment variable named port, I will use that. But just in case you are not giving me a port, let's fall back to 8, port. Yeah, so this one is nice. Now we can just say app, listen on this particular port and I can just say console log, that server is running on port Whichever port you are running on, that is this particular port. So this is our basic boilerplate code, right? And let's also create a dummy route that is app git, that is slash. So I can just say request response and return a new response. JSON saying status. Okay? Okay. So it's basically like server is up and running. So this is my basic boilerplate code. Let's also configure a dev script, okay, that is using the nodemon, because I don't want to restart the server again and again. So I can just say pnpm install or I can even use node hyphen hyphen Var. Okay. And I can just say index. Right? And similarly we can even have a start script that is node index. That's it. So if I say pnpm dev and enter, you can see that my server is actually running on port Nice. Okay, so this is basically nice. And one more thing, the warning that is coming, it basically says that, hey, can you please add the type module? Okay, so that everything is up and running. You can see now everything is up and running. That's absolutely great. Now we have to start by adding a database. So we are going to use Drizzle ORM. So we have already talked about Drizzle ORM. So let's go into the JavaScript and get started. So what we want to do is we want to use a new database that is PostgreSQL. We want to use basic file structure is there. So we have to follow the same thing. Okay, so it says that what you can do is you can have your schema ts. So it's basically in typescript. That is what they are telling you. Result config TS is there. So everything is there. So what we need to do is let's follow the same structure. Okay, so what I'M going to do is let's create a database. Okay? So I'll just create a new folder that is db. And inside the DB they recommend that what you can do is you can have something known as schema TS file. So schema js in our case. Okay, and let's also create an index js file. Nice. So these two files, basically I'm clubbing together. I don't think so. We need it. So I have just made it. So we will see it later. Then we have to make a drizzle config js file. Okay. Drizzle config js file. So this is our drizzle file. Now we have to say pnpm add these things we have to add. Okay, so that's fine. We can just say pnpm add drizzle, ORM, PG and env. Now what you will notice is that the pnpm is actually very fast. And let's also add these things. Okay, so I'm just saying enter and we are good to go. Nice. Then what we have to do is we have to make a database URL in a. env file. So usually we always keep our sensitive variables in a env file. And this env file is never ever pushed to the GitHub. Okay? So database URL, your passwords, your tokens, everything is stored in this env file. So this URL we will, create in a moment. So what we can do is we have to basically say we have to create this configuration, right? So we have to say import this particular stuff. I said, okay, see, I'm just copying from the documentation. Right? Then we have to import drizzle, okay, that is this particular thing. And then we can say, oh, by the way, this we have to do in the DB file, not here. Sorry, my bad. We don't have to do it here. We have to do it in the DB file. Okay, so which one was the db? In the index ts. So that is this particular file. Yeah, So I can just copy this whole thing and, and I can just paste in here. So this is basically the thing and don't need to put up this thing. So DB instance and we can just say export, default. Okay. Default the database. Okay, so we can just export the database from here. Nice. So what we have done is inside the DB index file we have made this initializer. Now we can create a table. Okay, so this table thing we will take care later. So drizzle. config file is something I'm interested in. So drizzle. config. GS file. So let's import env. Let's import the define config function. And what we have to say is we have to export default a configuration, right? Now what this configuration basically looks like is you have to say, out folder which is going to be dot result. Where is your schema? Okay, this is very important. Where is your schema? So I'll just say, hey, my schema is in the dot slash DB slash schema dot schema dot TS Sorry, js file. So this is the file I am pointing to. So just make sure that the spellings are all right. So schema js file dialect is PostgreSQL that we are going to use the PostgreSQL. That is nice. And database credentials, right? So database credentials are here. And process. env. database URL. So this is your drizzle configuration. Well done. Now what we have to do is basically, okay, we can make a schema. So inside the schema TS, this particular file, what we could do is we can import these things from the result and I can basically create a users table as it is. So it's a good thing that we are creating a users table which has an id. Okay, so what I will do is instead of making it as an integer, I would like to make it as a uuid. That is okay, we will see that in a while. So name is there. Age. Age is something we don't need. So we want to keep the email. We will keep password and all that stuff. Okay, so one thing that I want to change is that I will basically get a uuid. So I want to say that, hey, you are a UUID primary. And I can just say default to be random. Okay, so this makes more sense. Nice. Then user is going to have a name which is of a, varchar. Okay. Variable Character length is and not null. Email, length is this not null and unique. Then we can have a password, okay, which is again a varchar. Okay, we can have a varchar. Or maybe we can have a text. So let's take a text because I don't want to enforce any limit on this. So this can be text. Okay. And dot not null. Right? So this is basically not null. Okay, now here is the thing. See as a best practice, you should never store plain passwords. Okay? You should never store plain password. Because see what happens if your database is hacked? What happens if someone hacks your Database, what will happen? Your password is leaked. So ideally what we should do is we should hash this password, right? What we should do, we should hash the password given by the user. And, the best way to hash is we do something known as salt hashing. Okay. We do something known as salt hashing, which means for every user, what we can do is we can generate some random string. Let's say a random strings. Looks like ra. Okay, six, five, three. Something random. Okay, I'm just, I'm just, making a random string. Let's say my password was piyush So what we can do is instead of hashing piyush123, I can attach this random, salt. Now hash this whole thing together, and whatever the hash is generated for these two things that I can store as a password. And don't forget to also store the hashtag in the database. So that means password and salt will be stored. So password is this. Okay. And I will also store assault, for every user. So that means we are going to hash something based on a secret key where this is the password, this is a salt. Okay. This makes, you know, password more secure. Nice. Then you can have. I think these things are well and good for a particular user. Okay, so we have defined our schema. That is really nice. Our result configuration is also there. So now what we have to do, we have to just say NPX result kit push. Okay, but before that, before that, we have to set up our database. So to set up our database, I would like to use Docker. Okay, so Docker. So it's very simple. You have to first make sure that Docker is up and running. You have installed the Docker. So you can just download the Docker desktop using this. And here is, you can see all the installations and stuff. So don't worry. We will also attach an introductory thing to what is Docker and stuff? Okay, so make sure that Docker is up and running. So let me just, you know, spin up my Docker. So if I do enter. Let's wait for some while. All right, so my now Docker is up and running on my machine. Okay, so what I could do is if I come here and I just say, docker. P. S. you can see that, yes, Docker commands are running. That means my Docker is up and running. Now let's create a docker compose. yml file. Okay, so docker compose. yml file is here. Now what we could do is we have to just say services. Okay, nice and inside the services, what we have to do is we have to spin up a postgres so we can just search for postgres on the docker and enter. So you can see that this is the official documentation, right? How to use it. You can see if I just keep scrolling down. Okay, so I can just say my database. Okay, I can just say I want to spin up a db. Okay, My image is postgres. Okay, you can say just restart always. Okay. Just in case there is a crash. And then in the environment, okay, you have to basically give the postgres password. So let's say the postgres password is postgres itself. Or I can just say the password is post. I can just say my password. Okay, this is your postgres password. Of course, in the production you want to use something more big password. So that is okay, so postgres password you have set up. And also a postgres user we can set up. That is postgres. So. And don't forget to do the port mapping. So of course you want to also, you know, you want to expose the ports. So if you go on to the port mapping. Okay, Ports. So where is the ports thing? Yeah, so, not this one. So Postgres runs on Port, by the way. Anyway, if it is not suggesting you, I'll tell you. So one thing we can add here is postgres db so let's say my database name will be again postgres. Okay, Then port supports. It basically exposes port on This means inside the container on my host. Okay, so this is how basically it works. Sorry, on my host, inside the container. And at the end we have to give it a volume mapping. Okay, so I can just say volumes and we have to give a volume mapping that is DB underscore data. It is going to be a custom volume that we are just going to create. And you have to mount it on/war/lib/postgresql/data. Okay. So now what I can do is I have to basically create this volume. So I can just say volumes. Okay, Volumes and postgres DB data. And that's it. So this is the configuration. There's no need to give this thing. So we are creating a volume DB data which we are mounting here. And this basically spins up a postgres container for me. So I can just say docker compose up hyphen D to run it in the background. So let's see now what happens. It is basically pulling the database that is Postgres image is being pulled. So Postgres image is getting pulled. That is okay. It's just 124mb. Okay, so let's wait for a while. Yeah. So now you can see that my container is up and running. If I do a docker. P. S. you can see that. Yes, it is up and running. Right? The postgres container is up and running, and is the port that is available. Now, to construct this, we can just say postgres. This, this. Okay. What is your username, by the way? Your username is postgres. Okay? So you can just say postgres as your username. What is your password? Your password is my password, right? You can just say my password at the rate localhost port5432, slash, whatever is your database. So your database name is postgres. So this is how you construct a, a database URL. Nice. Now this database URL is set up. That is absolutely great. Now what we could do is if I come back, you can just say NPX Drizzle Kit push to push the schema to your database. Okay. And there is one more thing, by the way, if we go down, okay, we don't need seeding and all, there is something known as Drizzle Kit Studio. So you know what I like to do is let me just copy this particular command that is Drizzle Kit push and inside the package or JSON, let's configure these scripts. So I can just say DB colon push, Colon push is basically this command. And then I want to have a command that is DB Studio. Okay, so how to spin up a DB Studio? Let's just search for the studio. Okay, so drm, that is the studio. So to do that, what you have to basically do is, Yeah, here is the thing. Drizzle Kit Studio. Okay, so I'll just copy the command and paste it. If I now say PNPM DB colon do and enter. Okay, so you can see now this particular thing is up and running. I can just copy it. Okay, I can just copy and I can just open this particular link in a new tab. Okay, let's wait. What happens? So you can see that, the Drizzle Kit Studio is running. There is no table at all, zero tables in the public schema. So that means what we have to do is we have to say pnpm DB colon push and enter. Now If I do a refresh here you can see we have a users table which is have ID name, email password and salt and there is no record at all. Great, great stuff. Okay, so our setup is basically complete. Now let's get started by creating the routes. Okay, so for that let's create a folder for routes. Okay. And let's create a user do routes js. Okay, so here I have to import express from express. Okay. From express. Nice. Let's create a router that is express dot router. Nice. Now what we can do. Export default the router. Now on this router, what all do we need? I want router dot get. Okay, if you make a request on slash, this returns who is the current logged in user. Okay, so that means let's say there is no handler as of now, but I can add a comment. Returns current logged in user. Good. Similarly we can have a post. This basically does a sign up. Okay, sign up. So let's create a sign up route. Okay, nice. Sign up route is there. Then we can create a login route. Okay, create a login route. So this basically is the login route. If you want to log in and current user. I think these are all good. Okay, These all things are all good. So let's get started by creating the sign up route. Okay, so let's start by sign up route. So this is going to be an async function. Okay. Async request. Sorry, request, response. Now what I expect is that when you are signing up you are going to give me something in the body. That is what you are basically going to give me. Your name, your email and a password as a part of your body. Nice. Now see what we could do here is you can of course have a validation that password must be characters long. Right? There should be numbers in the password. All that stuff we can do. But okay, first things first, you want to check if your database already has this email or not. Correct. So what you could do is there are multiple ways to do it. Number one is that first you try to query that do you have an existing user? So how, how we can do is I can just say import DB from okay dot dot slash db and also you might want to import something from dot dot DB slash schema. Okay, slash schema. And you want to import the users table. Now you can first make a check for existing user that is await DB. Select something from you know, users table dot where. Okay, now in the, where you can just say okay, you can just return an equals okay eq Basically imported from the drizzle ORM you can just say, let me just make it into the new line so that you can see this these things clearly. Okay, where equals what I can just say where table. email equals to the email. So technically I'm trying to search for an existing user and a. I just want to query the email which is basically users table dot email. Now if you got the existing user. Okay, if I got the existing user. So I can just say return response status codeJSON saying error as user with email. Okay, let me just make it as a string. Literals. Okay, Email. This particular email already exists. Done. Now if it is not there, what you want to do, you want to basically create a new user, right? If user does not exist, you want to create a new user. So to create a new, create a user, I can just say await DB. Insert okay, in which table in the user table dot values. Now see here is the thing. You want to insert the name. That's good. You want to insert the email. That's good. Now here is the thing. You don't want to store the password, right? This is the wrong thing. This particular step is a wrong step because user is giving you a plain password. You don't want to store that plain password. So what we should do is first of all we should generate a salt. What is a gen, what is assault? A random string. A random bytes is basically a salt, right? So in node, how can you generate some random string? Okay, so if you go into the node crypto module, crypto random, okay? So this is a function that you can use. So crypto is there random bytes is there? So if I click here, okay, this is the official documentation of node js and I search for random, okay, random bytes. This is the one. So you can see from node crypto we can import random bytes. So I can just say import something from node crypto. And this is a built in module, by the way. So here you have a function that is random bytes. So I can just say random bytes. Okay, how much size I can like for example, say Then this generates random bytes for me, okay? And then I can just say that, hey, I want to make it tostring, okay, as a hex. So this salt is now a string, which is just a random string. Now using this salt, we can hash the password. Hashed password equals. How to do that? So for this particular thing, what you could do is now you can basically do a hashing, okay, how to Do a hashing. So for that you have to search for something known as. So there is a documentation where they use, I love cupcakes. Exactly. So you have to save create H mark. Okay, this is a function again coming from node crypto. So I can just import create hmark. Okay, so this created creates a hash. So I can say create hmac. Okay, which algorithm do you want to use? So there are multiple hashing algorithms. Let's say I will use Sh Then what is your secret? I say, hey, I want to use this salt. Okay, that's great. Then what do you want to update? Okay, I can just say dot update. What do you want to update? The user's password. Okay. And then finally just give me the hex version that is a string. So now this is a hashed password. Using this particular algorithm, using this salt, okay, we are updating the password. And as a hexadecimal. Now this password must be stored as hashed password. Really nice. And you can also keep this particular salt. So this particular thing creates a new user in the database. Okay, so cost user equals to. Then you can just say dot return. Okay, what do you want to return? I just want to return the ID which is users, table. it okay, so this user is basically. So this is actually an array which will always have one value. So I can just destructure it. Now I can just say return response. status code Because you have created a resource. JSON, i can just say status success and I can just send the data where I can have the user ID to be user. id. so this is what we can return. Ideally we should directly log in the user. But. Okay, so let's first test our signup route. So for that let me spin up my postman. So here is my postman. Okay, you can see here is the postman. So in the postman what we can do is let's try to sign up. So as of now, you can see in my Drizzle studio there is no user. So my server should be up and running. Oh, by the way, we forgot to register this route. Right. So I should basically do import user router from dot slash routes user routes. And then I should basically say hey app dot use. If anything starts with slash user, user, please use this particular router. Nice. Now PNPM dev. Okay, so we got an error, that is on this particular thing. It says that there is no module by this name. Okay, why is it so? Let me just check. Okay, let's give it a try again. Oh, the error is actually in the DB thing. Okay, so from where this particular error is coming, let me just do a quick check, directory import the db. Okay, so the problem is actually I think here, /index. js. okay, yeah, so now you can see everything is up and running on port So let's say HTTP local host Let me just make a request. Yes, the server is up and running. So if I want to sign up user sign up, is the route correct? So basically the route is if I go here/user/sign up. Okay, so in the body I have to give a raw JSON data. And by the way, because now you are handling the raw JSON data, please make sure that you have the middleware setup that app. use express. JSON. okay, so we have to send few details, that is name. Let's say piyush garg. Okay, email I can send piyushgar. devail. com Let me just zoom in a little bit so that you can see clearly. And let me just close this particular window. So localhost8000 is okay, so body, oh, here is the one. Okay, so this one is also good. And then I can just say password. So password is going to be Piyush Okay, let's do a send. And we got an error that is So it says that this particular route does not exist. Yeah, of course, because it has to be a post route send. We got user with email piyushgar uh. dev already exists. Okay, now there is something bad we have done here, right? Why? Let me just check. Okay, because this is an array, we should basically destructure it. This was the problem. Okay, now let's do a send. You can see a user is created with this particular id. Nice. If I go back to my database and if I do a refresh now you can see we have one user. And if I just do a refresh here you can see this is the user with this particular ID name, email. If you see closely, this is my password, right? Can you see that my password is actually hashed? This is what our password looks like. And this is what my salt looks like. So my Original password was piyush123 but we have hashed it to something this. So this is basically your hashing. Now no user or even a developer can go into the database and check for the password because this is hashed password. Nice. That is what we wanted, right? And this is basically what our whole table structure looks like. So this is also nice. Now our signup is working fine. If I again try to do a sign up, you can see user with this particular email already exists. Nice. Now what we should do, we should also do the login. Now login is what technically see what will happen is when user tries to log in, he has to give me his email and password. Now he will give you a plain password, right? What user remembers in his mind. What you should do is first of all you should search for the email in the database and retrieve the salt, right? You have the salt and you have the hash stored in the database. If I take the user's plain password using the salt, I again hash it. And if this particular hash matches, can I say the password is correct? Because see, in hashing world there is no concept of D hash. Once a thing is hashed, you cannot dehash it. So what I can do is I can repeat the algorithm, I can take this password, use this salt and again hash it. If this new hash is actually equal to the hash stored in the database, that means yes, user has entered the right password. So that means in the login route what we are going to do is let's say we have request, we have response and of course it has to be async. So what we are going to do is see number one. Let's first get the request body thing sorted. So I can just say hey, from the request body I want to have email and password. Okay? Now you have to search for this existing user. So just copy the logic and paste it here. Now here is a thing. If there is no existing user, that means you have entered an email which does not exist in the database, right? This is the wrong thing. So return response. status code that is JSON. Okay, and I can just send the error. Let me just make it 400, okay? In fact makes more sense that user with email. This particular email does not exist. You are trying to log in with an email which does not exist. But if the existing user is there. Okay, let's take the salt. So I have to query the salt from users table dot salt. Okay, so basically the existing salt is basically existing user dot salt. Also take the existing hash. What is the existing hash? You can basically query the password here. So I can just say password is users table dot password. So this is a hashed password, right? We know that. So existing user dot password. Now let's create a new hash. How to create a new hash. What I am going to do is same thing, just copy the same code. See, just copy the same code. This one. That is create hmark code. What I am going to do is I am going to take your password that you are giving me in the request body and I am going to use this salt and generate a hash. Nice. Now what I can say is that, see, if the new hash is not equals to. Is not equals to the existing hash, that means your password is incorrect. Okay, so we can just say response. JSON saying Sorry, response. Status. Okay, so this should be status. JSON saying error. That ideally your password is incorrect. So incorrect password. So this is your incorrect password. But if the password matches, you are here. So technically here, generate a session for user and return the success response response status. Okay, So I can just say, status success. So this is basically my login. Okay? So right now we are not doing any kind of session management. But ideally this is the logic. So that means now if I go back, copy this, make a new request post to the login. Okay, Login. What I'm going to do is raw JSON. Let me just copy this JSON from here. Now, technically, name is not required. Let me give an invalid email sent. You're getting User with this particular email does not exist. Nice. What if I give you A wrong password? 2, 3, Okay, double It says incorrect password. But if I give you the right password and I do a send, I get a success. So this is basically how you are doing a login. But technically this is not login, right? Login basically means generating a session on the database or generating a session. So for that what I could do is I can basically generate a session for this particular user, right? So session can be stored in the database. Great. So what I could basically do is I can just say I can create a new table that is user, sessions, right? I can just say PG table and name it as like user underscore sessions. Okay? And then this basically. And there I can just say, hey, every session is going to have a unique id. This ID can be anything, right? So I can just say it is again going to be uuid. This is session id. Okay, Then I am going to keep a, user id. This particular thing belongs to which user? So I can just say uuid. Okay, And I can basically say dot. If you say unique, if you add a unique here, which means one user can only have one Session. That means if he's logged in from mobile, he cannot log in from laptop because one user can only have one session. But no, we want that. Okay, you can log in from multiple devices. UUID is okay, I can just say references. I have to make a reference here. How to make a reference? I can just say, hey, this particular thing in the users table. id so this is a foreign key. Okay. And also make it not nullable, not null. Nice. And you can also keep created at that when this particular session was created. Right? You want to store that if this session is only valid for, let's say minutes, you want to invalidate this session after minutes. So you should also keep this thing. So I can just say created at is actually a timestamp. Okay, so let's just keep a timestamp. Okay dot DEFAULT is now and not null. Nice. So this is your sessions table. Now because you have made a new table, you have to say pnpmdb Colon, push and enter. So now you can see if I go into my studio and I do a refresh. Now I have user sessions now on login. What you should do now tell me the logic. Okay, you have to search for the logic. I have to basically create a new session. Okay, how to create a new session, I can just say await. In the users table, I can just say user session, User session. So I can just say user sessions. Insert sorry, DB. Insert into user session. Values. So I have to just say user ID, which is whichever user tried to log in. Right? That is this user. So I can just give it an ID. Also that is user table. id. so I can just say existing user. id. and when this particular session is created, you want to say dot returning. Okay, I can just name it as id, that is user sessions dot id. Once a session is created, you can just send this session ID as session id. Now, best thing is to actually also create a cookie. Okay, now what is a cookie? Cookie is basically what you could do is like you can store some extra information on the user's browser. But okay, as of now, let's say that you have created a token, a session id, a token for him. And now this particular token is sent to the user. Now every time he wants to get some resource from the backend, he has to it give back the session id. So if that user is having that session id, that means he is logged in. That's it. Okay, so we can just say pnpm dev again to start the server. Now Let me just try to log in again. Oh, nice. I got a session id. So this is my session id. Okay? So that means if I do a refresh, you can see that, you know, this particular user, this particular user has a session. So this user has how many sessions? As of now, only one session. Right. That means he's logged in from one device, which is this user. Piyushkar. Nice. Very nice. So that means if a session exists, if he has a session id, he's locked in. Now, you have successfully done one thing. That is how to sign up a user, how to log in, a user. Now, the problem is how to detect that if the current. Who is the current user? Right. How this backend will know who is the current user. So for that, we are going to create a middleware. So for that, we, have. We will continue this particular project in the next particular video, because I think this video is already long enough. So let's meet you in the next video.",
    "metadata": {
      "course": "02 Subtitles - Auth&Sec",
      "chapter": "04 Session Based Auth with Drizzle ORM.vtt",
      "filename": "04 Session Based Auth with Drizzle ORM.vtt",
      "originalPath": "02 Subtitles - Auth&Sec/04 Session Based Auth with Drizzle ORM.vtt",
      "type": ".vtt"
    }
  },
  {
    "id": "02_Subtitles___Auth_Sec_05_Building_Auth_with_Express_Middlewares_vtt_05_Building_Auth_with_Express_Middlewares_vtt",
    "content": "All right, so welcome to the another video in which we have to detect who is the current logged in user and how we can do that. So what we could do is be simple. It's very simple. We have already studied the concept of middlewares, right? The middlewares. See what I can do is technically, let's say that here is your user, right? This is the user or the client making a request to your express server. So these are your different, different routes. Let's say this is a route. Now one thing is what you can do is like you can write a logic of getting the current user here, right, in every route. For example, let me just code it, okay, for you. So let's say async request and response, correct? So what you can do is how. So you are expecting that request will somehow contain the session id. Okay, so let's say that user, you have told the user that hey, in the headers always give me an header that is let's say Session ID as whatever is your session id. Okay, so this is one thing that you are saying to the user. So you can assume that you are going to get the session ID of the user in the headers, that is Request dot headers, okay, as a key, that is Session id. Let's say now what you can do is you can write a logic, correct? What is the logic? You have to search a session by the id. So first thing first, if there is no session id, that means you are not logged in, right? Return response status code of unauthorized. Okay, so what is the unauthorized status code? Unauthorized status code 401, right? So you can just say JSON and and error that you are not logged in because you don't have a session id. But if you do have a session id, I want to search in the table, right? So I'll just make a query. Await, database. Okay. Select okay from which particular table okay. From which table that is sessions table. Okay, that's nice. Okay, where you will just say table equals okay, what that is table. id is session id nice. So what you are going to basically select from here is id, which is user sessions id. Nice. Now if this is not returning something, if you are not getting something that is const. Let's just call it as data. If there is no data, which basically means that there is no session, the session ID is invalid. Again, you can just say this particular thing, okay, that if there is no data, okay, that means you are not logged in. This is an invalid session ID you are sending me. But if you get it, you want to get the user information. So if you know that you have something known as user id in the user sessions. user id, right? So what you can do is you can basically do a for lookup, right? You can just say dot join. Okay, you can just do a dot left join, you can do a right join. So let's just do a right join. Okay, okay. On what table? On the users table. On the users table. Okay. On. Okay, how do you want to join it? So you have to give the on where users table. id. okay, you can just say where equals this particular thing to what thing? That is user sessions. user ID. So this is how you do a join. Now technically you can get the name of the user how you can just say users table. name and you can also get the email of the current user that is Users table dot email. So now this data contains everything. So you can just say if you got the data you can just say return response JSON and you can just send the data here. Let's first give it a try if everything is working. So let's say this is my session id, I'll just copy it. Let's make a new request, not a websocket request. I want to make an HTTP get request on HTTP user. If I just make a request to this particular route you can see it says you are not logged in. So I can just go into the headers. Let's create a new header of which name Session id. So I can just say session ID and value and send. So you can see this is the current logged in user. If this was an invalid ID let's say invalid ID you can see you are not logged in. Okay so one, so this is the current logged in user and nice. So now you can see that how you can basically save the current logged in user. Now let's say I have one more route that is a private route. Okay, so let's say I have a update route. Let's say user wants to update his some information. So it's a patch request. Okay, let's say router. patch/async request and response. And what you want to do is you want to basically update something from the current logged in user. So let's say he wants to update his name. So request body. So let's say name is something he wants to update. Now here is a problem right as Soon as you update the name you want to see if the current logged in user is who so you have to repeat this code, is that correct? So that means if you have a lot of routes, which has some private information, you want the information about the user, you have to repeat this piece of code, which is not a correct thing. So in Express, what you can do is you can basically create a middleware, a middleware, okay, which always runs. This middleware is responsible for fetching the session and keeping it in the data of the session and then forward the request to the route. Got it. Now so what we can do is this middleware can do the database operation and on the request it can create a new object named as user, which is basically the current logged in user, and then forward the request to the appropriate handler. That means if I go here, what I could basically do is I can create a middleware app. Use an async function. Okay, so this basically has request response. And next, see what I could basically do here. Okay, I'll just copy paste the code first, try to take the session id. If there is no session id, that means there is no user. Just call the next function. Right? Because next function can decide whether it wants to process that request or not. So I can just say a return. But if there is a session id, what do you want to do? You want to query that session. So I can just do a copy of this particular code, right? And paste it here. Now here is a problem. These things need to be imported. So don't forget to import these things. Okay, that is db. So this is just one level up, the db. And you also want to import this thing and this thing. Copy, paste and this thing. Nice. Okay, so that means you got the data. Now what you can do is if there is no data, if there is no data, okay, so that means, where is this ending somewhat here. If there is no data again, you can just call the next function without doing anything much. But if you got the data, you can just say request dot. You can add a new property, user, which is basically this particular data. Okay? Request user as data and then call the next function. So technically what is happening here is if the data is there, the request will have a new property, that is user. So that means if the user is actually logged in, request user will be added to the current request. That means now I don't have to do all this stuff. Okay, What I can just do is to get the current logged in user, I can just say const user equals to request user. That's it. If there is no user, I want to return this. So that means this logic has been removed. I don't want to query anything. Right. And then if the user is there, you just return this. That's it. Because you have moved that particular logic to the middleware, let's make sure if everything is working. Yes, everything is working fine. Got it. Now. Now, if you want to update something, first, you can basically check if that particular user exists or not. That's it. But if that user exists, of course you want the user id. So here is a problem. So this is basically your session ID. This is basically your session ID, not the user ID. So you might want to say where table. session ID and ID should be. Basically, user table ID. Okay, so user table. it nice. So now what you can do is you can just say to update something. I can just say await DB dot update. Okay, which table do you want to update? I want to update the users table dot. Okay, set. What do you want to set? I want to set the name. Okay, but where do you want to set the name? Okay, you can just say aware, where. Now this is very important. Equals user table. id is actually equals to request user. That is user. id. so this is basically request users current id. That's it. So you update it and then you can just say return response. JSON saying status success. That's it. Okay, so this is taking care of the, authentication using the middleware function. So now if I go back and I'm trying to make a get request first, you can see that, yes, I am getting everything that is nice. Now if I do a patch request, okay, on the body raw JSON. Okay, So I can just update my name, right? So from piyushkar, let's make it as piyush. Send success. Now if I make a get request and send, you can see my name is now updated, as piyush. So that means even in the database, okay, if I go into the users, it is now piyush. Okay, let's make it Piyush. Garg again PiyushGarg. Sorry, it's a patch send success. If you try to now get, you are getting piyushkarg. So if I do a refresh. Yeah, you can see it's now piyushkar. So this is how it is updating. Got it. Now, so this middleware is basically taking care of the authentication. So now this is basically what this is session based authentication. The problem with the session based authentication is this, that on every request you are making a database call. Do you see that? On every request you are making a database call. So just imagine if user is repetitively making request, you are actually doing a database operation on every request to exchange the session ID with the user's information. So that means this particular middleware which is always running, where is that middleware? Yeah, this is a very expensive operation. For every request you are making a database call, which is causing multiple problems. Problem number one, you are making a lot of calls to the database, which makes the database overwhelmed. Second problem is you are adding a latency, right? Because it's a database operation. In reality your database is running on a different server. So you are basically going to a database, getting the session information and then processing the request. So that means there is always an added latency, added some processing time to every request. Your every request will be slow because request came, you have first do the session thing in the database and then you have to again do database operation for some other thing. So that means this particular thing is making database call on every request, thus making every request slow and overwhelming the database. But it is more secure, right? Because every time you are making a database call. So what I could ideally do is now if I go back and I just delete the session, see, if I go into the sessions and I delete this particular entry, as soon as I delete now, you're logged out. See. So that means banking systems where the security is important, they use this session based thing. So with this particular approach you can even detect where all he is logged in. You can invoke revoke a session. So technically you can do a lot of things here, right? So this is basically your session based authentication. Now in the next particular video we are going to see how we can make a stateless authentication using JSON web tokens. And we can reduce this overhead. This always making an API call or making a query to the database more faster by not making it. So we will see how JSON web token solves this particular problem.",
    "metadata": {
      "course": "02 Subtitles - Auth&Sec",
      "chapter": "05 Building Auth with Express Middlewares.vtt",
      "filename": "05 Building Auth with Express Middlewares.vtt",
      "originalPath": "02 Subtitles - Auth&Sec/05 Building Auth with Express Middlewares.vtt",
      "type": ".vtt"
    }
  },
  {
    "id": "02_Subtitles___Auth_Sec_06_Stateless_Auth_with_JSON_Web_Tokens_vtt_06_Stateless_Auth_with_JSON_Web_Tokens_vtt",
    "content": "All right, so in this particular video, let's see how we can solve this session problem using something known as JSON web tokens. So that number one, I don't have to make an API call or a query call to the database and I don't overwhelm the database with every request and how I can increase my speed. So let's search for something known as JSON web token. Okay, so what is this? JSON web tokens. So this is the jwt, also known as JSON web tokens. The idea behind JSON web tokens is what if I could create a random string, let's say something like, you know, a random string and actual information about the user, such as name, such as all the details about the user can be encrypted inside the token. I mean the token itself contains the information. So that is the idea behind the jwt. So you can see that if this is a token, this token actually contains this information. Sub name id. For example, I can even add, let's say email, right? I can add email as P. So you can see that this particular token contains this particular data. So that means instead of returning a session id, I can return a, token, an encoded token which contains the all the information inside the token. So that is the basic idea behind the token. So I don't have to make an API call to the database to get the data. Okay, now these tokens are actually signed tokens. That means our server can basically create a token. Everyone can read what is the data inside the token, but no one can change it. Because to change the token you need a secret. Because if anyone can change this token, that's a very risky thing. You generate a token for me, I can update my user ID to point to your user ID and I can do something on your behalf. So these tokens are absolutely safe. Anyone can read these tokens, but no one can tamper or change these tokens until and unless you have the secret key. So as a developer you should always keep the secret key very secure. So what we are going to do is we are going to create a JWTSecret, which is something like, you know, Superman. So ideally it should be very long and something not guessable. Now what we have to do is we have to say pnpm install JSON web token. Okay, so this is the whole name JSON web token. Nice. Now see what we can do is let's try to refactor this particular code to use tokens. Okay? Number one thing, how do you login now that's the thing that when you log in, technically you don't want to create a session, right? We are not going to create a session, so a session creation is not required. Rather, what we should do is we should basically create a token for the user. How to create a token? First let's create a payload that what all information I want to store in the token. So I am going to store an ID that is existing user. id and I want to store email. Let's say existing user. email and I want to store the name of the user that is existing user email. Now to create a token token, I can just say import. Okay, import JWT from JSON web tokens. So this is what we have imported. And then you can just say jwt. sign. okay, you are signing a token for this particular payload and then you have to give the secret key that is process. en sorry process. env. what is the secret? Inside this is the secret JWT secret. This creates a token for you. Jwt. sign this thing. And this token can now be returned to the user back. So now let me show you what this token looks like. Okay, so what we are keeping in the token is id, email and name. Let's go back to the postman. So let me just spin up my postman. Okay, so here is the postman. And let's try to do a login. And send. Okay, I forgot to run the server, so PNPM dev and enter. Now let's see what is happening. And send. So all right, so we got an error. Let's see what is the error here. The. Okay, so my bad, actually the docker compose is not running. So docker compose up hyphen D. It says. Okay, so actually, you know, I just restarted my machine and the docker is not running. So that was the problem. So let me just, let's wait for a while. Yeah, now I think everything is up and running. Now let's just do a PNPM dev. Cool. And send. So can you see that? This random string, this is a token. Now if you have noticed, we are not storing this token in the database. There is absolutely no need to store these tokens in the database because if I paste my token here, See, See, this is what we are getting. By the way, name is wrong. My bad. Because this must be named. Yeah, so you can see that this is the token. Now you might be thinking that, hey, someone can come and change this token, but actually no, because if you change the token the signature of the token also changes. And to change that particular token, you actually need this particular key. So of course the user will never have this particular key. So they cannot really change the token. Now what we have to do is, okay, the login part is done. Now, in order to see if the current user is logged in or not. Now there is a thing. We don't really need this whole thing, right? What we need is we need to read the token from the headers. And as a part of standardization, there is always an authorization header, okay? So as a best practice, there must be a header that named as authorization whose value must be bearer. And the token goes here. So this is the standard practice that everyone follows. So this is basically your token header whose value should be bearer space and the actual token, okay? So that means first of all, if there is no token, if there is no token header, that means user is not logged in. Okay? Then you have to check that if okay, not token header dot starts with okay, it should start with the bearer. Okay, because that's the standard. Then you can just say return response. status as aJSON saying error and you can just say authorization header must start with bearer. Right? Nice. Bearer. Okay, if it starts with bearer, what you can basically do is you can basically extract the token. What I could do is if I somehow split this particular thing using the bearer word, right? Or if I split it using the space, okay? So I can just say token header. Split it using the space and take the first index that is this token. So you got the token. Now what you should basically do is you should validate, you should decode the token. So I can just say decoded. Okay, how to decode the token is basically import jwt from JSON web token and now you can just say jwt. Verify you have to pass the token. And also the same secret that you have used, that is process env. What was our key JWT secret. Now see, if user has changed something in the token, this particular step is going to fail. But if user has not changed something in the token, the decoder will be the actual user object, whatever you have stored in the token. Now technically I can just remove all this thing, right? Everything can be removed and this can be equals to the decoder. That's it. Absolutely no database call. You get the token header, which basically looks something like this. No token that means user is not logged in. If it doesn't start with bearer, you return a bad request error, you get the token from the header, you Decode it, you verify it, set the request header, and that is it. So that means now if I try to get myself, you can see it says you are not logged in. Why? Because this particular token has to be sent in such a way that is not this. Like this authorization must be bearer token and send. See, I am logged in. Also, can you see this authorization tab here? You can just say bearer token and you can actually paste your token here and send. So this is actually more nice way because Postman gives you the out of the box support for it. So there is absolutely no need to set this particular header, okay, because you already have it bearer token as a token. So this automatically sends a header. Okay, so if you see the hidden, you can see automatically an authorization bearer token is being sent. Nice. Okay, so this is how you basically do a token based authentication. Now see, when you are generating tokens, you can even give more parameters like expires in. So you can just say expires in. Let's say one minute. Now this particular token is only valid for one minute. That means after one minute, this token will no longer be valid. Okay, what happens if I change this token? Let's say if this was my token, right? Let me just copy the token, paste in the debugger. Because see, publicly anyone can read it. I change it. See, I'm changing something. Now if I copy this token, which I changed on the front end, of course, without the key, and I paste it. See? Server crashed. What? What is the error? If you read the error, it basically says that it is not able to verify the token. See, JSON web token error invalid signature. So that means if someone tries to tamper around with the token, tries to change the token, the validation fails. So ideally what you could basically do is in your middleware, okay? In your middleware, you can wrap this particular whole thing with a try catch. And if you are somehow in the catch, okay, you can basically just call the next function. That means you are not logged in. So now if this is a tamper token, you are not logged in. So that means you have to use the Tampa token, which is generated by the server using that secret key and then paste in here. See, you change something in the token and your signature is invalid. See, I changed it. Copy it. Okay, now if I use this particular token, you are not logged in. Nice. Right? I'm not making an API call. I'm not making a database call. Why? Because the actual data sits inside the token. That is the beauty of JSON web tokens. Okay, so this is how we are doing it. And by the way, the name is not coming here because we are not querying the name here. So ideally I should also query the name. Okay, so that's okay, you can just update this particular stuff. But so tokens. The basic idea behind tokens is that the actual information is actually stored inside the token itself so that you don't make a database call always. And because the actual data lives inside the token, the latency is very less because you just have to verify the token, you are not making an extra database call. So database is not overwhelmed with every call. But there is a problem. Once you create a token and you give it to the user. Now technically you don't have any control on the token, right? He is logged in. You get it now because see, when you were doing session based authentication, if you want to log out a user, you can just delete his session from the database. But now once you give a token to a user, there is no way going back. You get it now the token is with him. How will you invalidate this token? So ideally the best practice is that you should not create long tokens. You can just create a token which is for one minute. And if it is expired, you can just regenerate a token for him. You can just regenerate a token for him for one, one minute. And if you don't want, if you want the user to be logged out, just stop regenerating the tokens for him. See what happens is the worst case is that he will be still logged in for one minute. That's the thing. And you might be thinking, I can store this particular token in the database. You should never store the tokens in the database. But yes, you can maintain a database of, you know, blacklisted tokens, okay, where you can store the token of the, you know, which you want to invalidate. But the problem is again you will end up in the same problem. That is you are making a lot of database calls. So the decision is yours, that if you are making an application where authentication is very sensitive, like banking, there you should always implement a session based authentication. But if you are just building a SaaS where it's okay to log in a user for a couple of seconds right there, the token based authentication is used because it leads to less overhead on the database. Okay? So it's a balance between both of them. So you should always create tokens with less expiry time. So expires in one minute. And as soon as the token expires you can regenerate the token for him. So this is basically how the token based authentication works. So congratulations. Now you know both of the authentication methods, that is Session based authentication and GWT based authentication. This is stateless. This is what? Stateless. Why is this known as, stateless? Because. Because the data is stored inside the token and session based is basically stateful because the actual data lives on the server or on the db, so that is the whole thing.",
    "metadata": {
      "course": "02 Subtitles - Auth&Sec",
      "chapter": "06 Stateless Auth with JSON Web Tokens.vtt",
      "filename": "06 Stateless Auth with JSON Web Tokens.vtt",
      "originalPath": "02 Subtitles - Auth&Sec/06 Stateless Auth with JSON Web Tokens.vtt",
      "type": ".vtt"
    }
  },
  {
    "id": "02_Subtitles___Auth_Sec_07_Introduction_to_Authorization_vtt_07_Introduction_to_Authorization_vtt",
    "content": "Okay, so welcome to one another exciting video in the authentication section. And in this particular video we are going to cover the concept of authorization. So now at this particular point we already know what is authentication. Authentication means that the server knows who are you. That means you are authenticated. And there are two ways of authentication. Number one, there's a session based authentication where you give a session ID or a temporary ID to a user, where the data about that ID is stored on the server, maybe in a database, maybe in your memory. And that is where you let the user authenticate it. And on the other hand you had a stateless version of the authentication that was JSON web tokens where you actually store the information about the user inside the token itself. So that was authentication that whether you are authenticated or not. Does server recognize you? Do server know who are you? That is authentication. Now let's jump onto the concept of authorization. Authorization is basically the next step of the authentication. In order to be authorized to do something, you have to be first of all authenticated. There is no authorization possible without authentication. So first step is something that we have already done. Authorization means if you have access to a particular resource or not. So let's imagine that this is a user, that is U1, okay? And this is a user, let's say U2, okay? Now in on your server, okay, on your server, let's say you have multiple routes, right? You have a lot of data on the back end. Now let's say you want makes a request to get some piece of data. Okay? So let's say that this is basically a data about all the payments. So let's say you were building some financial application and this is the data about all the payments. Okay? So all the payment data lives here. Now technically, if you imagine this thing, payments data is a critical data, right? You don't want to share this particular thing publicly or something, something like that. So now you have to build a mechanism that if you want, hey user one, are you really allowed to access this data? If so, you have to return this data to the user. But if not, see if he does not have that particular access, you can just return return an unauthorized error. So number one thing is that number one, see this U1 user has to be authenticated. That means server knows who the U1 is. Then the next step comes that do you have the permission to access this particular resource? If so, you can return this data. If not, just return an error response. So how can you achieve this particular thing? It's very simple. I mean there are a lot of techniques to implement authorization, but let's cover the simplest one, that is just attach a, role to this user. So let's say if U1 has a role, which is admin, right? Very simple. And you too has a role that is, let's say, simple user. Now if the role is admin, you return this particular data, but if the role is not admin, you are not going to return this data. And what is this role? At the end of the day, this role is nothing but just a value in the database. So in the users table, I can extend that table to have one more entry, I. e. role, where default value can be user, and we can promote special users to be admin. And then we can even store this particular thing in the user's token, right? You have JWT tokens, which are signed tokens. No one can change it. So in the JWT token I can just write role admin, and then I can check that if you are an admin, only and only then you are allowed to access this particular resource. So basically this is how the authorization happens. So this is the basic concept behind the authorization. So what I would like you to do is pause the video right here. Implement. Try to implement this particular thing on your own before jumping onto the next video. Because in the next video I will be coding this particular thing. I'll be refactoring the whole code, but I would like you to give it a try first. So let's meet you in the next particular video.",
    "metadata": {
      "course": "02 Subtitles - Auth&Sec",
      "chapter": "07 Introduction to Authorization.vtt",
      "filename": "07 Introduction to Authorization.vtt",
      "originalPath": "02 Subtitles - Auth&Sec/07 Introduction to Authorization.vtt",
      "type": ".vtt"
    }
  },
  {
    "id": "02_Subtitles___Auth_Sec_08_Adding_Support_for_Roles_in_our_express_app_vtt_08_Adding_Support_for_Roles_in_our_express_app_vtt",
    "content": "All right, So I hope that in the previous video you have already given some try in implementing authorization. But just in case you were not able to, don't worry, here we are to implement the authorization. So what I'm going to do is first things first, let's say we don't have any concept of authorization, right? I am going to create a special route, let's say admin routes js as the name says. This particular routes is going to contain some critical routes which are only and only be allowed to an admin. So what I can do is first of all I'll just borrow some code that is import express from Express. That is nice. So I'm just importing the express and let me just create a new router that is this particular stuff and then I can just say export default. Okay, Export default the router. So imagine all the routes that we are going to add here is only and only be restricted to the admin only. Okay, so let's create a router, A, get route Users. Let's say admin wants to see all the users that are available in our database. Technically it's an internal information. You don't want that any person can see all the information about the available users on the platform. But yes, admin can see all the users. So let's say this is one route that I want to build. So let's just quickly code this particular route. So I'll just create an asynchronous function here. Okay. And I'll just say request response. And let me just zoom in the code little bit more so that you can see it more clearly. So how to implement this particular stuff is first of all let's import DB from DB js file. Okay, nice. And let's also import something from you know, one directory up. Then we can go into the DB and then we can go into the schema js file. So what do you want to import here? I want to import the users table. Nice. So here we have the db oh by the way, I imported it wrongly. I should have done DB slash index js Yes. Now it is basically the database. You can see it's a database file. Nice. So now what I want to basically do here is my router is here. So how to query all the users? I can just say const Users equals to. I can just put an await and then I can just say DB dot select. Okay, from which table do you want to select? I want to select from users table and that's it right this basically means select all the users. Then I can just say return a, response. JSON saying users. That's it. So this users is what? Basically an array of users. And of course you don't want to send password, right? You don't want to send the password and salt on the front end. So let's add, that, hey, I want to send an ID that is user stable ID. I want to send the name that is users table. name and I want to send the email that is user stable email. That's it. That's it. I want to send. Now let me just quickly spin up my postman, okay. And test this particular route if this is working or not. Right now you can see we have not done any authentication. No authorization. Nothing is there. Right? So here is my postman. Right? So what I'm going to do is, by the way, we forgot to register this particular router. So we have to go into our index js file. Let's import this routes, right? So I can just say import, admin router from dot slash routes admin router js. So what I could basically do, I can just say if anything starts with admin, you please use the admin router. That's it. And by the way, I have just noticed we have a lot of unused imports, so it's okay to remove them. Right? Nice. So let me just start my server up and running. So PNPM dev starts my server at localhost Great. So if I say admin slash users, I will clear my token. See? No authentication. Okay, let's clear the body, no body, no header and send. You can see I'm able to get all the users. So as of now, we only have one user in our database. Correct. Technically, this is wrong. First thing we should implement is that the user must be authenticated. Correct user must be authenticated. Now, one way to do the authentication is I can just say that if there is no request dot user. Right? If you remember from the previous classes, we have a middleware function. If the user exists, we are populating this request user. So if there is no request user, that means the user is logged out. You can just say return a, response. status code of and then saying. JSON. okay. And error that. Oh, sorry, error. Please don't import this error from here and you can just send an error that you must be authenticated to access this. So this is one way of controlling the authentication. Right? So now if you send, you can see you Must be authenticated. But now if I try to send the bearer token along, okay, I have to generate, I have to log in first. So let me just do a quick login. This is my token. Let me just copy this token and I'm just going to replace this token and send. Now you can see the authentication is working. Now. Guys, tell me one thing, is this a correct way to do an authentication? Of course not, right? Technically I don't want to repeat this code. If you see we are repeating this code at couple of places, right? We are repeating this particular code at couple of places. So you should not repeat a code. Rather see what I could do. I can create a folder of middlewares, right? And I can create a middleware of auth middleware js. What I can basically do in this auth middleware js is I can create a middleware number one. I also want to first of all move this middleware to this file, right? To make it more clean. So let's create a middleware here that is const, authentication middleware. Let's name it as authentication middleware. So this middleware does what? It's just an asynchronous function. Okay, let's say it's an async function. And what it basically has, it, it has access to request response. And next. Now what I can do is I can safely. First of all, let's have a try catch. See, I'm just going to type, I'm just going to type here. So what we are basically doing here is try catch. If there is any error, just call the next function. Okay, that's it. But if it is not what you do, you try to read the headers. Okay, I'm just copying one by one. Okay, Try to read the headers. Try to. If the header does not exist, that means, okay, the user is not authenticated, he's not sending you any kind of headers. Just call the next function next, you know, next router in the middleware stack. Okay. But if it does not start with the bearer, of course it's an error. So you can just throw an error response. Nice. Cool. Okay, then you got the token. So I'll just copy here and I'll just say, hey, here is the token. Very nice. Then you try to decode the token. Right? Right. So you want to make sure that this token is generated by you. So you do a, verify. But don't forget to import jwt. So import JWT from JSON web token. Nice. And if you got the decoded you just say request user is equals to decoded and call the next function. Very nice, very nice. Okay, and just export this function from here. Now what you can basically do is instead of this logic, I can say, hey, I want to import something from dot slash middlewares slash, you know, auth middleware. And you can just import the authentication middleware. Now instead of doing all this particular stuff here, I can just make it say app. Use the authentication middleware. That is it. Right? Let's make sure if everything is working, you can see everything is working. Right? I'm still logged in. And if I say no, you can see I'm logged out. If I say bearer token, I am logged in. Very nice. Now what I can do is along with this I can create one more middleware. I can just say export const Ensure authenticated. Now basically what I'm trying to do here is this is again a function. Okay, let's say it's an again async function which has access to request response. And next, this middleware ensures that you have to be logged in. Okay, that is very simple. If no request user, this is going to say return response status, sorry, response status of JSON. And I can just say an error that is you must be authenticated. But if it is not the case, I can just call the next function. So this is a very simple logic which makes sure that the user is authenticated. So that means to use this particular middleware, what I could basically do is I can go into this user route, correct? And what I can do, I can basically import something from middleware auth middleware and I can try to import the ensure authenticated. And just by putting this thing here. Now this particular function will only run if user exists. So now I can safely remove this nice similar. I can just put it here, ensure authenticated. And I can just remove this logic. Because technically this function right here, which I am highlighting will only run if this middleware calls the next function. This middleware will call the next function only if request user exists. Nice. Right, so ensure authenticated basically can be even used here. So instead of doing this thing, I can say import something from dot dot slash middlewares auth middleware import ensure authenticated. Put ensure authenticated as a middleware on the route level and remove this. That's it. Let's test it out. Send. Is it working really nice. No, auth send. You can see it's not working. And if I say bearer token and Send, you can see. Nice. Cool. Now, similar to this, similar to this, let's start adding the authorization. Correct. So what is authorization? Technically what I could do is I can add a new field here. Okay, that is a role. Now role can be basically a string. Role can be an enum. So it is basically what I would like to do is I would like to create an enum. So pgenum. So let's say export const User role. Enum. Okay, Equals to pgenum. Let's call this enum as user, underscore role. Okay. And values can be either a user or the values can be either an admin. Let's say these are the only two available values. So I can say that, hey, you are basically a, enum. Okay, that's great. And you are not nullable. And your default value is what? Your default value is basically user. Nice. So this basically adds a role property to the user. So let me just do one thing. Let me just pin up a studio first. PNPM DB Studio. Okay, DB Studio enter. My DB Studio is up and running on this particular link. So let me just open the link. Not, user only num. I have to copy this. So I copied the wrong thing and paste it here. Now let's wait for a while so you can see in the users. Right now there is no role. Right. So what I'm going to do, create a new terminal PNPM DB push. So this has applied the changes. Now if I go back and I do a refresh now, you should be able to see a role in the users. So if I just say users, where can I see? Okay, let me just remove this. Can I see the role? Yes. So you can see that the role is user. Right. Now what I could do is. That is good. The role is user. Very nice. Technically, when you log in, okay, when you log in, what I should do is I should also put this role in your token. So when I'm trying to do a login, I should also query for the role that is user table dot role. Okay? Now in the payload I can also put a role that is existing user dot role. That's it. Great. So now the role is also in the payload. That means if I log in once again. Now this is my new token. I copy this particular token and I go on to JWT IO website. Okay, Just for the debugging purpose and I paste it here. Now you can see this is what my token payload looks like. You can see I have id, I have email I have name role. Now technically, this role is very interesting, right? Based on this role, what I can do, I can create one more middleware that is restricted, say restrict to admin. Okay? Or I can say restrict to role, which is an async function. Okay? What this function basically takes is a role. You have to give me a role which can be either admin or this can be either user. Correct? So this can be either admin or user. So it's basically a role. Okay? Now see, what I can do is I can return a new function from here which has request a response and a next correct. There is no need to be async. This is okay, now see what I can do. We can basically assume the user is already authenticated. I can just say if request user. role is not equals to this particular role. Correct. In this case, I can just say return response dot status code. Okay? That is 4, of course, dot JSON error. You are not authorized, okay? To access this resource. Very nice. Else, sorry, resource. Okay, very nice. But if, if the role exists, you can just say the return the next function. That is it. Now see what I could do. It's basically a closure function. If I call this function with role as admin, this returns me a middleware function, right? This is how I have designed it. And then this middleware function can be used. So it's a closure function. So that means going on to the admin routes. Now I can import an authentic. Sorry, the restrictor role. Now technically what I can do is I can just say construct, admin restrict. Okay? Restrict middleware. Okay. Equals to restrict to role admin. Nice. And then I can also change the admin restrict middleware. Now this particular route is only and only restricted to the admins. Let's give it a try. Okay, so if I copy this particular token, I have a new token, paste it and send. You are not authorized. You are not authorized. Why? Because my role is user. Correct. If I go in my database, I change my role to admin. I have to now log out and log in. Basically I have to generate a new token for myself. Right? Because, you might have heard that whenever there is a problem, often the admin asks you to hey, can you please do a logout and login so that your token is refreshed. Now my token contains the role as admin. Nice. Now what I can do. Now if I go here, I replace my token and I do a send. Now you can see I'm able to access this resource, right? So this is basically kind of a role based access control using the middleware. So congratulations. Yes, it was that simple to implement. Okay, so you can have multiple roles, not only user and admin, you can have moderator, you can have multiple roles. Then you can just create a middleware, a utility function which checks for that role and you can just chain it. Now technically I don't want to put it here right. If you see all the roles here are going to be restricted to admin. So what I can do is I can put it on a router level that is router use number one is ensure authenticated and router use admin this thing. Now I don't have to put on every route. So now every route that I create in this particular file will use these two middlewares because these middlewares are applied on the route level. So going back test your implementation, everything is working fine. Nice.",
    "metadata": {
      "course": "02 Subtitles - Auth&Sec",
      "chapter": "08 Adding Support for Roles in our express app.vtt",
      "filename": "08 Adding Support for Roles in our express app.vtt",
      "originalPath": "02 Subtitles - Auth&Sec/08 Adding Support for Roles in our express app.vtt",
      "type": ".vtt"
    }
  }
]